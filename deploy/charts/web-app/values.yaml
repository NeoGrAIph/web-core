# Base values for `web-app` chart.
# Rule: no plaintext secrets in `web-core`. Provide secret names/keys only.

nameOverride: ""
fullnameOverride: ""

image:
  repository: "REPLACE_ME"
  tag: "REPLACE_ME"
  pullPolicy: IfNotPresent
  pullSecrets: []
  # - name: regcred

service:
  type: ClusterIP
  port: 3000

ingress:
  enabled: true
  className: "traefik"
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
    traefik.ingress.kubernetes.io/router.tls: "true"
  redirectToHttps: false
  redirectPermanent: true
  hosts: []
  # - host: corporate.dev.example.com
  #   paths:
  #     - path: /
  #       pathType: Prefix
  tls: []
  # - secretName: corporate-dev-tls
  #   hosts:
  #     - corporate.dev.example.com

env: {}
  # SYNESTRA_ENV: "dev" # dev|stage|prod
  # NEXT_PUBLIC_SERVER_URL: "https://corporate.dev.example.com"

envFrom:
  secretRef: ""
  # secretRef: web-corporate-dev-env
  extraSecretRefs: []
  # extraSecretRefs:
  #   - web-corporate-dev-s3-env

resources: {}
  # requests:
  #   cpu: 100m
  #   memory: 256Mi
  # limits:
  #   cpu: 500m
  #   memory: 1Gi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 2
  targetCPUUtilizationPercentage: 80

persistence:
  media:
    enabled: true
    mountPath: /app/public/media
    size: 5Gi
    storageClassName: ""

postgres:
  # Канон по умолчанию: БД управляется платформой в namespace `databases`,
  # а приложение получает `DATABASE_URI` через `envFrom.secretRef`.
  # Включайте `true` только для POC/экспериментов (per-namespace CNPG Cluster).
  enabled: false
  clusterName: postgres
  instances: 1
  storage:
    size: 5Gi
    storageClassName: ""
  bootstrap:
    secretName: ""
    # secretName: web-corporate-dev-db-init
    database: ""
    # database: corporate
    owner: ""
    # owner: corporate
  appUserSecretName: ""
  # appUserSecretName: web-corporate-dev-db-app

migrations:
  enabled: true
  # IMPORTANT:
  # We run migrations as a `Sync` hook with a later sync-wave than the Postgres cluster.
  # Using `PreSync` deadlocks the first install when the DB is created by this chart.
  hook: Sync
  hookDeletePolicy: BeforeHookCreation,HookSucceeded
  syncWave: "1"
  command:
    - sh
    - -lc
    - |
      set -e

      if [ -z "${APP_NAME:-}" ]; then
        echo "APP_NAME is not set (expected pnpm workspace package name, e.g. @synestra/synestra-io)" >&2
        exit 1
      fi

      if [ -z "${DATABASE_URI:-}" ]; then
        echo "DATABASE_URI is not set" >&2
        exit 1
      fi

      echo "Waiting for Postgres to accept TCP connections..."
      i=0
      until node -e 'const {URL}=require("url");const net=require("net");const u=new URL(process.env.DATABASE_URI);const host=u.hostname;const port=u.port?Number(u.port):5432;const s=net.connect({host,port,timeout:2000},()=>{s.end();process.exit(0)});s.on("error",()=>process.exit(1));s.on("timeout",()=>{s.destroy();process.exit(1)});' ; do
        i=$((i+1))
        if [ "$i" -ge 150 ]; then
          echo "Postgres is not ready after 300s" >&2
          exit 1
        fi
        sleep 2
      done

      pnpm --filter "$APP_NAME" payload migrate

jobsRunner:
  # Включайте в prod, если используете `versions.drafts.schedulePublish: true`.
  # CronJob вызывает встроенный endpoint Payload: `GET /api/payload-jobs/run`.
  enabled: false
  schedule: "*/1 * * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 3

argo:
  syncWaves:
    postgres: "0"
    app: "2"
    jobsRunner: "3"
