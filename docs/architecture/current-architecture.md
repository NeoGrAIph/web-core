# Текущая архитектура web-core (контекст появления)

Документ фиксирует актуальную архитектуру `web-core` и причины, почему она сложилась именно так. Это “живой срез” для ориентира при развитии проекта и обработке шаблона `website` из upstream.

## Контекст появления
- Исходная точка: официальные шаблоны Payload CMS 3 (особенно `website`).
- Задача: собрать устойчивую компонентную платформу для сайтов на Payload + Next.js без форков shared‑кода.
- Ограничение: сохранить возможность точечных overrides и стабильного продвижения изменений через `payload-dev → payload-core`.
- Дополнительная цель: не завязывать UI на Tailwind‑мажор и минимизировать зависимость от внешних пакетов.

## Репозитории и роли
- `web-core` — монорепо приложений и shared‑пакетов (UI, CMS‑слой, утилиты). Здесь живут каноны модульности и фасады.
- `synestra-platform` — инфраструктура GitOps (Argo CD, образы, секреты, окружения). Здесь фиксируется, какие версии `web-core` реально развернуты.

## Приложения и окружения
- `payload-dev` — рабочая среда для обкатки shared‑изменений (Next.js dev‑режим, быстрые итерации).
- `payload-core` — эталонный prod‑контур (стабильный результат, используемый как база для доменных сайтов).
- URLs:
  - dev: `https://payload.dev.synestra.tech` (режим разработки).
  - prod: `https://payload.services.synestra.tech` (prod‑режим; дополнительно — демонстратор технологий).

## Канон изменения кода
1. Извлечь/сформировать модуль из существующих файлов (ориентируемся на upstream‑структуру).
2. Описать модуль в `README.md` и зафиксировать источники/решения в `docs/research/...`.
3. Применить и проверить в `payload-dev`.
4. Перенести стабильный результат в `payload-core`.
5. Продвинуть в prod через `synestra-platform` (образ → Argo CD).

## UI‑слой и фасады
- Прямые импорты `@synestra/ui/*` в приложениях запрещены.
- UI подключается через фасад `@/ui/*`.
- Админ‑компоненты подключаются через фасад `@/admin-ui/*` и import map Payload.
- Локальные overrides разрешены только на уровне приложений (`apps/<site>/src/ui/*`).

## Payload Blocks и registry
- Страницы собираются из Payload Blocks через типизированный registry.
- Schema/renderer держатся синхронно и оформляются как повторно используемые модули.
- Это позволяет расширять функционал без форков и без разрыва типизации.

## Источник правды для шаблонов
- Официальные upstream‑шаблоны не правим.
- Текущий шаблон реализован на базе обработки `website` из upstream.
- Процесс обработки документируется в:
  - `docs/research/templates/payload-website/processing-project.md`
  - `docs/research/templates/payload-website/processing-progress.md`

## Интеграция с платформой
- Версии `web-core` фиксируются в `synestra-platform` и попадают в образы.
- GitOps‑контракт: продвигаем изменения только после проверки в dev.
- Каноны: env‑контракт, миграции, seeding, media‑политика (см. runbooks).

## Что это дает
- Повторно используемая база компонентов и схем без копипасты.
- Контроль качества через `payload-dev`, прежде чем попасть в prod.
- Прозрачные overrides и предсказуемые границы между UI, admin‑слоем и доменными приложениями.
