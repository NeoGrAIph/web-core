# Компоненты: структура и переиспользование

Цель (из курса `Production Monorepos with Turborepo`, последовательно: секции 2/3/4/5/8):

- уменьшить копипаст при создании новых компонентов/пакетов;
- фиксировать стандарты структуры (имена файлов, тесты, экспорты);
- унифицировать компоненты так, чтобы из них получались **универсальные, настраиваемые** блоки для разных apps.

Контекст `web-core`:

- несколько Next.js apps (`apps/*`) с независимыми деплоями;
- общий код живёт в `packages/*`;
- есть несовместимость UI-стека по upstream: Tailwind 3.x vs Tailwind 4.x, поэтому **core UI не должен зависеть от Tailwind** (пока не будет принят единый major).

---

## 1) Границы (что где живёт)

Базовый принцип из курса: **apps implement, packages reuse**.

### `packages/ui` — общий UI (переиспользуемый)

Назначение:
- примитивы и композиции, которые должны работать в нескольких apps;
- минимальная стилизация через **CSS variables/tokens + props**, без привязки к Tailwind major;
- публичный API через **named exports** (subpath exports) + опционально barrel из корня.

Запреты:
- не тянуть app-специфичную бизнес-логику;
- не тянуть Payload-конфиги/модели конкретного сайта;
- не делать “скрытые” зависимости на глобальные стили конкретного app.

### `packages/cms-blocks` — “контентные блоки” Payload (схемы/типы)

Назначение:
- описания блоков Payload (`blocks`) и их типы, пригодные для повторного использования.

Запреты:
- не тянуть React/Next UI (рендеринг — отдельным слоем);
- не тянуть app-специфичные поля.

### Связка “Payload blocks → React UI” (без копипаста между apps)

Рекомендуемый паттерн (чтобы не дублировать рендеринг блоков в каждом app):

1) `packages/cms-blocks` задаёт **тип данных блока** (и Payload schema).
2) В каждом app живёт **registry** “тип блока → React компонент” (тема/обёртки остаются в app).
3) Общий рендерер (опционально) может жить в `packages/*` и принимать registry как параметр:
   - `renderBlocks(blocks, registry)` (pure функция) или `<BlocksRenderer blocks registry />`.

Это даёт:
- единый контракт блоков (данные одинаковые),
- независимую тему/стили в каждом app,
- минимальный копипаст при добавлении нового блока (добавили schema + компонент + регистрация).

### `apps/*` — интеграция, тема и “конечная сборка страниц”

Назначение:
- композиции уровня продукта/сайта;
- стилизация (Tailwind 3/4, глобальные стили, темы);
- связка “Payload данные → блоки → UI”, включая маршрутизацию/кеш/preview.

Практическое правило:
- если компонент “про данные/поведение конкретного сайта” — он в app;
- если компонент “про общий UI-контракт и его можно применить ≥2 apps” — он кандидат в `packages/ui`.

---

## 2) Типы компонентов (слои библиотеки)

Чтобы не превращать `packages/ui` в “свалку”, делим компоненты на уровни:

1) **Primitives** — маленькие, максимально универсальные:
   - `Button`, `Card`, `Text`, `Container`, `Stack`, `Input`…
2) **Composed** — композиции из primitives без доменной логики:
   - `ModalShell`, `Field`, `Callout`, `Pagination`…
3) **Domain UI (опционально, отдельными пакетами)** — если появится домен:
   - `packages/marketing-ui` (корпоративный сайт/лендинги),
   - `packages/commerce-ui` (каталог/карточки товаров).

Правило переноса:
- (в духе секции 3 курса) сначала делаем в app, затем — выносим в shared при появлении стабильного повторного использования.

---

## 3) Публичный API и структура файлов (стандарты)

### Импорты (как в курсе: named exports)

Предпочтительный стиль:

- `import { Button } from '@synestra/ui/button'`

Допускается (для удобства, но не “дефолт”):

- `import { Button } from '@synestra/ui'`

Запрещаем deep-imports вида:
- `@synestra/ui/src/...` (ломает инкапсуляцию и усложняет рефакторинг).

### Рекомендуемая структура `packages/ui` (эволюционная)

Пока компонентов мало — допустима “плоская” структура (как сейчас):

```
packages/ui/src/
  button.tsx
  button.test.tsx
  card.tsx
  index.ts
```

Когда компонентов станет много — группируем по слоям, сохраняя внешний API через exports:

```
packages/ui/src/
  primitives/
    button/
      button.tsx
      button.test.tsx
      index.ts
    card/
      card.tsx
      card.test.tsx
      index.ts
  composed/
    modal-shell/
      modal-shell.tsx
      modal-shell.test.tsx
      index.ts
  client/
    modal/
      modal.tsx
      modal.test.tsx
      index.ts
  index.ts
```

Снаружи это остаётся стабильным:
- `@synestra/ui/button`
- `@synestra/ui/modal-shell`
- `@synestra/ui/client/modal` (или другой согласованный префикс)

### Имена файлов

- файл компонента: `kebab-case` (например, `button.tsx`, `modal-shell.tsx`);
- тест рядом: `button.test.tsx`;
- если компонент требует клиентского рантайма — отдельный “client export” (см. ниже).

### Минимальный контракт компонента

Каждый компонент в `packages/ui`:
- принимает `className?: string` (как “escape hatch” для apps);
- фиксирует минимум `variant`/`size` через union-типы (если применимо);
- не навязывает Tailwind-классы.

---

## 4) Универсальность и настраиваемость (паттерны)

### 4.1 Variants вместо копипаста

Как в уроке про `Button variant` (секция 2 курса):
- вместо двух почти одинаковых компонентов вводим `variant` (`'primary' | 'secondary' | …`);
- стили переключаются либо через CSS variables, либо через `data-атрибуты`.

Рекомендуемый базовый механизм:
- компонент выставляет `data-variant`, `data-size`, `data-tone`;
- app-слой (Tailwind 3/4 или обычный CSS) решает, как именно это стилизовать.

### 4.2 Композиция вместо “монолитов”

Как в уроке про `SnippetCard = Card + CodeBlock` (секция 3 курса):
- делаем маленькие “кирпичи”;
- собираем более крупные компоненты как композиции;
- избегаем доменных зависимостей в `packages/ui`.

### 4.3 Server/Client граница (Next.js App Router)

Практическое правило:
- по умолчанию компоненты в `packages/ui` должны быть **server-safe** (без хуков);
- интерактивные вещи (hooks/state/порталы) — отдельными экспортами, например:
  - `@synestra/ui/client/modal` (или отдельный пакет `@synestra/ui-client`).

Это снижает “расползание” `'use client'` по дереву.

---

## 5) Тестирование и регрессии

Как в секции 5 курса:
- `packages/ui` — первая “точка отказа”, поэтому тесты обязательны хотя бы для primitives;
- минимальный стандарт: Vitest + Testing Library, тесты рядом с компонентом.

Рекомендация по приоритету:
- primitives: тестируем обязательно;
- composed: тестируем поведение/контракт, не “пиксели”;
- app-специфичное: тестируем в app (или e2e позже).

---

## 6) Генераторы (как убрать копипаст)

Как в секции 8 курса:
- внедряем `@turbo/gen` после стабилизации структуры `packages/ui`;
- генератор должен создавать:
  - файл компонента,
  - файл теста,
  - добавление экспорта в `packages/ui/src/index.ts`
  - (опционально) добавление subpath export в `packages/ui/package.json`, если мы решим полностью “named exports only”.

Предлагаемые команды (целевой UX):
- `turbo gen ui:component` → primitive/composed (с выбором),
- `turbo gen ui:client-component` → компонент с client-границей,
- `turbo gen package` → новый shared package по стандарту `@synestra/<name>`.

---

## 7) Чеклист “вынести в shared”

Компонент кандидат в `packages/ui`, если:
- используется или планируется в ≥2 apps;
- API можно стабилизировать (понятные props, нет “случайных” зависимостей);
- он не зависит от конкретного Payload-конфига/коллекций;
- есть тест (или компонент слишком простой и тест очевиден/дешёвый).

Компонент остаётся в app, если:
- привязан к домену конкретного сайта (контент, фичи, аналитика, AB);
- зависит от окружения/маршрутов/данных, характерных только для одного app;
- это временная итерация, и API “плывёт”.

---

## 8) Процесс добавления нового UI-компонента (Definition of Done)

1) Определить слой:
   - primitive / composed / client / domain(app).
2) Создать компонент и типы props:
   - обязательно `className?: string` (и при необходимости `variant/size`).
3) Добавить тест (минимум: “рендерится/детерминированно работает”).
4) Экспортировать через публичный API:
   - `packages/ui/src/index.ts` (и при необходимости subpath export в `packages/ui/package.json`).
5) Заменить копипаст в app(ах) на импорт из `@synestra/ui/*`.
6) Проверить, что компонент не тащит Tailwind-специфику и не требует `'use client'` без причины.
