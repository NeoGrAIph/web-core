# Payload CMS v3 (v3.68.3) — конспект официальных материалов (для Synestra)

Дата актуальности: **2025-12-15**.  
Закреплённая версия в `web-core`: **Payload 3.68.3**, **Next.js 15.4.9**.

Цель: зафиксировать ключевые свойства Payload 3, которые влияют на:
- структуру монорепозитория `web-core` (apps/packages),
- GitOps-модель (сколько деплоев/namespace/DB у нас будет),
- удобство разработки (особенно dev-loop и шаблоны сайтов).

Этот документ — **не решение**, а “карта местности”: что говорит официальный Payload, и какие архитектурные выводы из этого следуют для нас.

---

## 1) Источники (официальные/приоритетные)

- Payload GitHub Releases (версионирование, security fixes):
  - `https://github.com/payloadcms/payload/releases`
- Payload 3.0 announcement (ключевые изменения v3):
  - `https://payloadcms.com/posts/blog/payload-30-the-first-cms-that-installs-directly-into-any-nextjs-app`
- Production Deployment (официальные рекомендации по продакшену):
  - `https://payloadcms.com/docs/production/deployment`
- Multi-tenancy overview (позиционирование + пример):
  - `https://payloadcms.com/multi-tenancy`
- Blog: How to Build a Multi-Tenant App With Payload (механика domains/tenant scoping):
  - `https://payloadcms.com/blog/how-to-build-a-multi-tenant-app-with-payload`

---

## 2) Что принципиально изменилось в Payload 3 (важно для структуры репо)

### 2.1. Payload стал Next.js‑native

Официально: Payload “устанавливается внутрь Next.js приложения” и backend+admin живут внутри Next.js проекта. Это значит, что базовой единицей деплоя становится **Next.js app**, в которой уже “встроен” Payload.

Практический вывод для `web-core`:
- наша текущая модель “каждый сайт = отдельный Next.js app в `apps/*`” — естественная для Payload 3;
- “frontend и backend отдельно” по-прежнему возможно, но это уже выбор, а не необходимость.

### 2.2. Local API в server components / server functions

Официально: можно использовать local API прямо на серверной стороне Next.js (минуя HTTP), что даёт быстрый доступ к данным и упрощает внутренние интеграции.

Практический вывод:
- для общего UI/блоков/виджетов группы компаний это означает, что shared packages в `packages/*` могут безопасно содержать серверные утилиты (если мы держим границы зависимостей под контролем).

---

## 3) Продакшен‑деплой (официальные требования) и что это значит для GitOps

### 3.1. Базовая мысль

Официально: Payload деплоится “везде где может работать Next.js”, но почти всегда нужен ещё DB + файловое хранилище + email + CDN.

Практический вывод:
- наша модель “1 deployment = 1 namespace + 1 database” хорошо укладывается в эту картину.

### 3.2. Секретный ключ (PAYLOAD_SECRET)

Официально: `secret` (обычно `PAYLOAD_SECRET`) должен быть длинным/сложным, и в продакшене обязателен SSL, чтобы включать secure cookies.

Практический вывод:
- секреты не кладём в `web-core`; они должны попадать в Pod через `Secret` (платформенный репозиторий).

### 3.3. DATABASE_URI и адаптеры БД

Официально: templates обычно используют `process.env.DATABASE_URI` и ожидают доступ к БД из окружения.

Практический вывод:
- “контракт env vars” для web‑apps должен всегда включать `DATABASE_URI`;
- миграции должны выполняться на каждом окружении (dev/prod) в рамках GitOps‑жизни приложения.

### 3.4. Хранилище файлов (media)

Официально: если используем upload‑коллекции, то на проде нельзя полагаться на ephemeral FS; нужен persistent volume или внешний storage (S3‑подобное).

Практический вывод:
- наши Helm values должны явно задавать, где живёт `public/media` (PV или внешний storage), и это должно быть частью “шаблона сайта” по умолчанию.

---

## 4) Multi‑tenancy в Payload: что это может дать и какая цена

### 4.1. Что предлагает Payload (официально)

Payload позиционирует multi‑tenancy как “один код — много tenants”, включая сценарии “разные домены на один инстанс” и tenant‑scoped доступы в admin.

В официальном гайде/примере встречается паттерн:
- у tenant есть `domains: string[]`,
- на login/requests используется `req.headers.origin` для определения tenant,
- доступ/видимость данных ограничивается tenant’ом.

### 4.2. Главный trade‑off для нашей платформы

Если выбрать multi‑tenancy “внутри одного Payload‑инстанса”:
- **плюс:** меньше деплоев в Kubernetes, меньше Argo CD Applications → “масштабирование GitOps” становится проще;
- **минус:** это уже **не** “1 сайт = 1 namespace = 1 DB”, а “много сайтов/тенантов на одной БД и одном инстансе” (изоляция хуже, обновления сложнее катить выборочно).

Также важно помнить: “несколько подключений к разным БД из одного Payload‑инстанса” официально не является поддерживаемым/рекомендуемым сценарием (на уровне community guidance это описано как “не поддерживается; лучше один большой DB или отдельные инстансы”).

### 4.3. Как это связано с вопросом “directory vs ApplicationSet” в Argo CD

Это и есть связь с нашим “вторым вопросом”:
- если мы выбираем **multi‑tenancy** (один инстанс на много доменов) → Argo CD приложений будет мало, и нам долго может хватить “ручного списка” applications;
- если мы выбираем **multi‑app** (каждый сайт — отдельный Payload/Next app + отдельный namespace/DB) → Argo CD приложений будет много, и тогда становится важным, **как мы масштабируем GitOps‑описание приложений** (directory/apps-of-apps сейчас, ApplicationSet возможно позже).

---

## 5) Рекомендация “на сейчас” (в контексте уже выбранных принципов)

У нас уже зафиксирован принцип: **монорепа для скорости, независимые деплои для безопасности** + “один namespace + одна database per deployment”.

Поэтому базовый безопасный маршрут:
- каждый сайт = отдельный app в `apps/*` (Payload встроен в Next.js app),
- общие вещи выносим в `packages/*`,
- Argo CD: фиксированные dev/prod приложения (ручной список в `deploy/argocd/apps/**`),
- Okteto используется как dev-loop поверх dev‑деплоя (а не как замена GitOps).

Multi‑tenancy можно рассматривать позже, но как осознанный продуктовый/архитектурный поворот (а не как “оптимизация YAML’ов”).

---

## 6) Открытые вопросы для дальнейшего исследования (Payload 3)

1) Что именно считаем “сайт” в Payload‑терминах:
   - отдельный Next.js app + свой Payload config,
   - или один app + tenants + доменная маршрутизация.
2) Какие “конструкторные блоки” должны быть shared:
   - UI компоненты (server/client),
   - Payload Blocks/Fields,
   - коллекции/глобалы/feature flags.
3) Как закрепить migrations‑политику как runbook:
   - когда создаём миграции,
   - как выполняем их в dev/prod,
   - что делаем при rollback’ах.

