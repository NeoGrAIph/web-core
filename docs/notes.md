# notes.md

## Полезные факты

- Зафиксированный стек для `web-core`: `payload` v3.68.3 и `next` v15.4.9.
- Выбранный подход для hot‑разработки в Kubernetes (одна нода): Okteto.
- В репо добавлен снапшот официального Payload template `templates/website` в `upstream/payload/templates/website` (для референса, не для прямого деплоя).
- В official Payload `templates/website` зафиксирован Next.js `15.4.9` и показан минимальный набор env vars для запуска: `DATABASE_URI`, `PAYLOAD_SECRET`, `NEXT_PUBLIC_SERVER_URL`, `CRON_SECRET`, `PREVIEW_SECRET` (см. `upstream/payload/templates/website/.env.example`).
- В репо добавлен снапшот официального Payload template `templates/ecommerce` в `upstream/payload/templates/ecommerce` (для референса). В `.env.example` у него есть Stripe‑ключи (`STRIPE_SECRET_KEY`, `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`, `STRIPE_WEBHOOKS_SIGNING_SECRET`) и он использует `@payloadcms/plugin-ecommerce`; в README указано, что шаблон BETA. Также в зависимостях указан Tailwind `^4.0.12` (в отличие от `templates/website`, где Tailwind 3.x).
- Страницы курса Vercel Academy закрыты без авторизации, поэтому для исследования мы используем текст страниц, который ты присылаешь в чат (ссылка + содержимое).
- Курс “Production Monorepos with Turborepo” описывает типичные боли polyrepo: дублирование изменений UI, рассинхрон конфигов (ESLint/TS), отсутствие кеширования между связанными изменениями, сложность координации релизов; заявленная цель — решить это монорепой + кешированием Turborepo. Источник: `https://vercel.com/academy/production-monorepos`.
- В курсе заявлено 8 секций: основы монорепо, общий UI‑пакет, добавление второго приложения, общие конфиги/утилиты, тестирование (Vitest) с кешированием, оптимизация pipeline (filtering + remote caching), масштабирование на несколько apps с независимыми деплоями, enterprise‑паттерны (генераторы, changesets, governance, next-forge). Источник: `https://vercel.com/academy/production-monorepos`.
- Упор курса на “production patterns”: постоянно деплоить, измерять cache hits/время сборки/URLs, наращивать сложность итеративно. Источник: `https://vercel.com/academy/production-monorepos`.
- Урок `Understanding Monorepos` задаёт базовый паттерн монорепы:
  - `pnpm-workspace.yaml` включает `apps/*` и `packages/*` (packages может быть пустым на старте, но структура заложена заранее),
  - `package.json` в корне — координатор задач через `turbo run <task>`, с минимумом devDependencies, фиксацией `packageManager` (pnpm) и требований к Node,
  - `apps/<app>/package.json` — стандартные скрипты/зависимости приложения (например Next.js), без “turbo‑логики” внутри.
  Источник: `https://vercel.com/academy/production-monorepos/understanding-monorepos`.
- Remote caching — ключевая фича Turborepo, которая позволяет ускорять повторные и частичные сборки (пересобирать только затронутые пакеты при изменениях). В примере Vercel автоматически включает Turborepo Remote Caching и в логах видно “cache hit / FULL TURBO”. Источник: `https://vercel.com/academy/production-monorepos/understanding-monorepos`.
- Принцип “Monorepo ≠ Monolith”: монорепа — про расположение проектов в одном Git‑репозитории, монолит — про архитектуру приложения/деплоя; это независимые понятия. Источник: `https://vercel.com/academy/production-monorepos/understanding-monorepos`.
- Урок `Monorepos vs Polyrepos` вводит практические понятия:
  - **coordination tax** polyrepo: изменение общего пакета каскадируется в несколько репозиториев (несколько PR/CI + version management),
  - **atomic changes** в монорепе: изменение общего API и всех потребителей в одном коммите,
  - **TypeScript verification**: компилятор сразу ловит breaking changes по всем потребителям.
  Источник: `https://vercel.com/academy/production-monorepos/monorepos-vs-polyrepos`.
- Правило выбора: monorepo — для связанных приложений с общим кодом и частыми сквозными изменениями; polyrepo — для действительно независимых проектов (разные стеки/команды/доступы/циклы релизов). Источник: `https://vercel.com/academy/production-monorepos/monorepos-vs-polyrepos`.
- Практический совет курса: при сомнениях начинать с monorepo; разнести монорепу на несколько репозиториев проще, чем объединять множество репозиториев с сохранением истории. Источник: `https://vercel.com/academy/production-monorepos/monorepos-vs-polyrepos`.
- Урок `Turborepo basics`: кеширование работает через хеш инпутов (исходники+deps+конфиги+env), при совпадении хеша Turborepo делает cache hit и “replay outputs”, при изменениях — cache miss и пересборку; `--dry-run` показывает план и хеши. Источник: `https://vercel.com/academy/production-monorepos/turborepo-basics`.
- Базовые паттерны `turbo.json` (Turborepo 2.x): `dependsOn: ["^build"]` для сборки зависимостей раньше потребителей; `outputs` определяет кешируемые артефакты (для Next: `.next/**` и исключение `!.next/cache/**`); `globalDependencies` инвалидирует кеш глобально при изменении файлов (пример: `.env.*local`); `dev` задачи обычно `cache: false` и `persistent: true`. Источник: `https://vercel.com/academy/production-monorepos/turborepo-basics`.
- Урок `Add features page`: сначала намеренно создаём дублирование (6 одинаковых inline “Card” div’ов + повтор nav/styles) в одном приложении, чтобы затем извлечь это в `packages/ui` при появлении второго приложения/страниц. Источник: `https://vercel.com/academy/production-monorepos/add-features-page`.
- Практика из урока: Next.js App Router страницы живут в `apps/web/app/...` (пример: `apps/web/app/features/page.tsx`), а общий UI позже выносится в `packages/ui` и подключается как workspace dependency. Источник: `https://vercel.com/academy/production-monorepos/add-features-page`.
- Commit-message пример для изменения в одном приложении: `feat(web): ...` (подсказка к конвенции “scope=app”). Источник: `https://vercel.com/academy/production-monorepos/add-features-page`.
- Урок `Create UI package structure`: базовый shared пакет создаётся как `packages/ui` и регистрируется через workspace (`pnpm install`), React задаётся как `peerDependencies`, а `exports` готовится под named exports (например `@.../ui/card` вместо barrel `@.../ui`). Источник: `https://vercel.com/academy/production-monorepos/create-ui-package`.
- Named exports предпочтительнее barrel exports из-за tree-shaking, явных импортов и меньшего риска циклических зависимостей. Источник: `https://vercel.com/academy/production-monorepos/create-ui-package`.
- В уроке есть несостыковка: в “Done-when” упоминается `tsconfig extends @tsconfig/nextjs`, но пример `tsconfig.json` не содержит `extends` — в нашей реализации нужно выбрать единый стандарт (наследование от общей базы vs локальные compilerOptions). Источник: `https://vercel.com/academy/production-monorepos/create-ui-package`.
- Урок `Extract card component`: локальный пакет подключается в приложение через `@.../ui: "workspace:*"` (pnpm), а компоненты импортируются по named export пути (`import { Card } from '@.../ui/card'`). Это убирает version bump/publish цикл и даёт мгновенные обновления во всех местах использования. Источник: `https://vercel.com/academy/production-monorepos/extract-card`.
- Next.js: заявлено, что с Next 15+ и Turbopack локальные workspace‑пакеты работают без `transpilePackages`; для старых Next (<15) может понадобиться `transpilePackages: ['@.../ui']`. Источник: `https://vercel.com/academy/production-monorepos/extract-card`.
- Типовой баг: `Cannot find module 'react/jsx-runtime'` в shared UI лечится тем, что в `packages/ui` должны быть TypeScript и типы React/ReactDOM в `devDependencies`, после чего `pnpm install`. Источник: `https://vercel.com/academy/production-monorepos/extract-card`.
- Урок `Extract button component`: повторяет паттерн `packages/ui/src/*` + `exports` + `index.ts`, но добавляет в `Button` проп `variant` (`primary|secondary`, default `primary`) для переиспользования в разных контекстах. Источник: `https://vercel.com/academy/production-monorepos/extract-button-component`.
- Паттерн масштабируется: компоненты добавляются в `packages/ui/src/`, затем открываются через named exports (`@.../ui/button`, `@.../ui/card`) и используются в любых `apps/*` без publish/version bump. Источник: `https://vercel.com/academy/production-monorepos/extract-button-component`.
- Урок `Deploy web app`: для CI/деплоя критично использовать **filtered builds** (например `turbo build --filter=web`), иначе монорепа будет собираться “целиком”. Remote caching в CI даёт огромный выигрыш: изменения вне инпутов сборки (например README) дают remote cache hit и билды на сотни миллисекунд вместо десятков секунд. Источник: `https://vercel.com/academy/production-monorepos/deploy-web-app`.
- Важный вывод: `packages/ui` в таком подходе — build-time dependency, а не отдельный runtime deployment; UI компилируется внутрь `apps/*` при сборке Next. Источник: `https://vercel.com/academy/production-monorepos/deploy-web-app`.
- Урок `Create snippet manager app`: второй app в `apps/*` подключает тот же `packages/ui` через `workspace:*`, меняет dev‑порт (пример: 3001), и запускается вместе с первым app одной командой (`pnpm dev` через Turborepo). Это демонстрирует “monorepo orchestration” и параллельный build нескольких apps. Источник: `https://vercel.com/academy/production-monorepos/create-snippet-app`.
- Урок `Build snippet list page`: второй app начинает реально импортировать и использовать `Button`/`Card` из `packages/ui`, а затем демонстрируется hot reload “в обоих apps одновременно” при правке `packages/ui/src/button.tsx`. Это подтверждает, что shared UI — один источник правды без publish/version bump. Источник: `https://vercel.com/academy/production-monorepos/snippet-list-page`.
- Для Next App Router важно управлять client/server границей: для интерактивности страница помечается `'use client'`, а обработчик `onClick` у Button может быть заглушкой (`console.log`) на старте. Источник: `https://vercel.com/academy/production-monorepos/snippet-list-page`.
- Урок `Add CodeBlock and SnippetCard components`: рост UI‑библиотеки через композицию (SnippetCard использует Card + CodeBlock). Это убирает повторяющийся JSX в приложениях и делает изменения в дочернем компоненте (CodeBlock) мгновенно видимыми во всех составных компонентах. Источник: `https://vercel.com/academy/production-monorepos/add-codeblock-snippetcard`.
- В уроке есть важная развилка для нас: ранее `packages/ui` описывался как “source-only без build task”, но в примере `turbo build` фигурирует `@geniusgarage/ui:build`. Это влияет на нашу стратегию (будем ли мы добавлять build для `packages/ui` или оставим его как TS source, потребляемый apps). Источник: `https://vercel.com/academy/production-monorepos/add-codeblock-snippetcard`.
- Урок `Add snippet creation modal`: интерактивность реализуется в app через `useState` (snippets/showModal/form state), модалка рендерится условно, Create добавляет новый сниппет в начало списка, Cancel закрывает модалку (опционально сбрасывая форму). Источник: `https://vercel.com/academy/production-monorepos/snippet-creation-modal`.
- Важная практическая деталь: если забыть перейти с `mockSnippets` на `snippets` state в маппинге, новые сниппеты не будут отображаться (частая ошибка при “оживлении” статической страницы). Источник: `https://vercel.com/academy/production-monorepos/snippet-creation-modal`.
- Урок `Deploy both apps`: один репозиторий → два независимых “проекта деплоя” (у каждого свой root directory и `turbo build --filter=@.../<app>`), при этом оба включают `packages/ui` как зависимость. Идея переносится на Kubernetes как “несколько deployments из одной монорепы” с независимыми релизами. Источник: `https://vercel.com/academy/production-monorepos/deploy-both-apps`.
- Оптимизация: selective deploy/rebuild — не пересобирать app, если изменения не затронули его директорию и shared deps (`packages/ui`). На Vercel это делается через Ignored Build Step с `git diff ...`. Аналог нужен в GitLab CI через `rules:changes` или вычисление затронутых пакетов. Источник: `https://vercel.com/academy/production-monorepos/deploy-both-apps`.
- Урок `Extract shared configs`: вынос повторяющихся `tsconfig.json` и eslint правил в отдельные пакеты `packages/typescript-config` и `packages/eslint-config` (one package per tool). Apps “тонко” подключают их через `extends`/import, что устраняет drift и облегчает добавление новых apps. Источник: `https://vercel.com/academy/production-monorepos/extract-shared-configs`.
- Турбо-оркестрация для tooling: `lint` добавляется в `turbo.json` с `dependsOn: ["^lint"]`, после чего `pnpm lint` проверяет несколько apps параллельно; единое правило (например `no-unused-vars`) ловит ошибку в любом app одинаково. Источник: `https://vercel.com/academy/production-monorepos/extract-shared-configs`.
- Альтернатива: Biome (lint+format на Rust) может радикально ускорить монорепу, если линт >30с, но ценой экосистемы плагинов. Источник: `https://vercel.com/academy/production-monorepos/extract-shared-configs`.
- Урок `Add shared utils`: чистые функции (formatDate/slugify/truncate/validateEmail) выносятся в `packages/utils` и переиспользуются в apps; `createdAt` лучше хранить как `Date`, а форматировать на UI‑уровне через общий `formatDate`. Источник: `https://vercel.com/academy/production-monorepos/add-shared-utils`.
- Важная мысль: монорепа — не только про UI‑компоненты; можно шарить конфиги, утилиты и (позже) бизнес‑логику (`packages/core`). Источник: `https://vercel.com/academy/production-monorepos/add-shared-utils`.
- Урок `Update Turborepo pipeline`: `dependsOn: ["^build"]`/`["^lint"]` — явный контракт “сначала задачи зависимостей, затем потребителя”; чтобы пакет участвовал в графе `turbo build`, у него должен быть `scripts.build` (для `packages/ui` и `packages/utils` предлагается `tsc --noEmit`). Config packages build‑скрипты не требуют (статические файлы). Источник: `https://vercel.com/academy/production-monorepos/update-turborepo-pipeline`.
- Изменение в пакете должно инвалидировать build зависимых apps даже без правок в их коде — это ожидаемое поведение “умного” кеша в монорепе. Источник: `https://vercel.com/academy/production-monorepos/update-turborepo-pipeline`.
- Урок `Set up Vitest`: тесты должны жить рядом с исходниками в `packages/ui` и запускаться автоматически; базовый сетап — Vitest + React Testing Library + jest-dom + jsdom, `vitest.config.ts` с `environment: 'jsdom'` и `setupFiles`, скрипты `test` (CI) и `dev:test` (watch). Источник: `https://vercel.com/academy/production-monorepos/set-up-vitest`.
- Для тестов важно не завязываться на конкретную реализацию стилей (например Tailwind классы) до выбора стратегии стилизации `packages/ui`, иначе тесты будут хрупкими. Источник: `https://vercel.com/academy/production-monorepos/set-up-vitest`.
- Урок `Write component tests`: тесты в `packages/ui` расширяются до “контрактных” проверок поведения для `Button/Card/CodeBlock` (variants, children, onClick, props) и при желании включают coverage (v8 + html/text). Источник: `https://vercel.com/academy/production-monorepos/write-component-tests`.
- Best practice из урока: тестировать поведение (семантические запросы `getByRole`, события), а не внутреннюю реализацию; проверки “классов” возможны, но их нужно привязывать к стабильной системе стилей. Источник: `https://vercel.com/academy/production-monorepos/write-component-tests`.
- Урок `Configure Turborepo for tests`: добавляем `test` task в `turbo.json` (без dependsOn, outputs `coverage/**`) и root script `test: turbo test`, чтобы одной командой прогонять тесты по всем пакетам с кешированием; `--dry` показывает план, `--force` игнорирует кеш. Источник: `https://vercel.com/academy/production-monorepos/configure-turborepo-tests`.
- Кеш тестов инвалидируется по изменению исходников/тестов/`package.json` и окружения (Node/env vars). Это значит, что фиксация версий Node/pnpm в CI влияет на cache hit rate. Источник: `https://vercel.com/academy/production-monorepos/configure-turborepo-tests`.
- Урок `Test caching in action`: hash для `turbo test` включает исходники, тесты, package config, глобальный конфиг (turbo.json/root package.json/.gitignore), workspace dependencies и команду задачи. Поэтому изменение `turbo.json` или shared config packages инвалидирует кеш для зависимых тестов, а изменения в несвязанных apps — нет. Источник: `https://vercel.com/academy/production-monorepos/test-caching`.
- Практика: `turbo test --dry=json` позволяет увидеть task hashes; локальный turbo cache хранится в `node_modules/.cache/turbo/`. Remote caching даёт максимальную выгоду в CI, если CI может “подхватить” кеш, прогретый разработчиками. Источник: `https://vercel.com/academy/production-monorepos/test-caching`.
- Урок `GitHub Actions CI pipeline`: CI должен запускать `turbo build lint test` одной командой (для параллельности и кеша), кешировать зависимости (pnpm) и пинить версии инструментов; следующий шаг — filtering/affected packages, чтобы не гонять весь workspace на каждый мелкий PR. Источник: `https://vercel.com/academy/production-monorepos/github-actions`.
- Урок `Filtering and git-based filtering`: `--filter` позволяет запускать задачи точечно, а `--filter=[origin/main]` делает git-based фильтрацию по изменившимся пакетам и их dependents. Это ключ к ускорению CI на небольших PR. Источник: `https://vercel.com/academy/production-monorepos/filtering-git-based`.
- Урок `Remote caching setup`: remote cache шарит outputs задач (build/test/lint) между разработчиками и CI; один раз собрал локально → CI может скачать артефакты и получить cache hit вместо пересборки. На Vercel это включается через `turbo login` + `turbo link` и переменные `TURBO_TOKEN`/`TURBO_TEAM` в CI. Источник: `https://vercel.com/academy/production-monorepos/remote-caching`.
- Безопасность remote cache: кешируются outputs/stdout/stderr, но не исходники и не секреты; CI токен предпочтительно read-only, локальные токены — read-write. Источник: `https://vercel.com/academy/production-monorepos/remote-caching`.
- Урок `Add docs app`: третий app добавляется “дёшево” благодаря фундаменту (shared packages/configs/utils + turbo/CI). После добавления `apps/docs` Turborepo автоматически видит новые задачи, а `pnpm dev` может запускать все apps параллельно; правка `packages/ui` должна hot reload’иться сразу во всех apps. Источник: `https://vercel.com/academy/production-monorepos/add-docs-app`.
- Урок `Deploy all apps`: каждый app деплоится независимо (свой root dir/URL/env vars), но изменения shared packages (например `packages/ui`) должны триггерить rebuild всех dependents, а изменения только в конкретном app — rebuild только этого app. В CI git-based filtering должен подхватывать новый app без доп. настройки. Источник: `https://vercel.com/academy/production-monorepos/deploy-all-apps`.
- Урок `Multi-app development`: стандартные режимы локальной работы — запуск всех apps (`pnpm dev`), одного app (`pnpm --filter <app> dev`), нескольких apps (несколько `--filter`), и запуск по паттернам (`--filter "./apps/*"`). Это нужно документировать и стандартизировать по портам/командам. Источник: `https://vercel.com/academy/production-monorepos/multi-app-development`.
- Урок `Turborepo generators`: генераторы (`@turbo/gen`) автоматизируют создание компонентов/пакетов по шаблону (файл компонента + тест + обновление exports), уменьшая копипасту и ошибки (забыли экспорт/тест, разный нейминг). Источник: `https://vercel.com/academy/production-monorepos/turborepo-generators`.
- Урок `Changesets for versioning`: changesets фиксируют “намерение” semver bump (patch/minor/major) и генерируют CHANGELOG’и; полезно даже без публикации в npm, чтобы отслеживать breaking/feature изменения в `packages/ui` и других shared packages. Apps с `workspace:*` не требуют ручного обновления версий зависимостей. Источник: `https://vercel.com/academy/production-monorepos/changesets-versioning`.
- Урок `Code governance`: нужен ownership (CODEOWNERS) + enforced quality gates (protected branches, обязательные approvals от code owners, обязательный CI). Это особенно важно для shared packages (`packages/ui` и конфиги), потому что их изменения затрагивают все apps. Источник: `https://vercel.com/academy/production-monorepos/code-governance`.
- Страница `next-forge patterns`: next-forge — референс “как масштабировать” паттерны курса (много доменных `packages/*`, строгий TS, advanced turbo pipeline, security/observability). Для нас это источник идей по границам пакетов (`packages/auth`, `packages/db`, `packages/observability`) и по toolchain (Biome) при росте монорепы. Источник: `https://vercel.com/academy/production-monorepos/next-forge-patterns`.
- Текущее целевое направление: инфраструктура остаётся в `~/synestra-platform` (GitOps для платформы), а сайты/код/шаблоны деплоя и CI для приложений — в монорепозитории `~/repo/web-core`.
- Окружения закладываем как `dev` → `stage` → `prod`, но на старте работаем и публикуем только в `dev`, чтобы не перегружаться процессами, пока продукт активно меняется.
- Принятое решение по изоляции: отдельный namespace и отдельная БД на каждый deployment (корпоративный сайт, интернет‑магазин, SaaS, лендинги).
- Принятое решение по БД на deployment: CloudNativePG Cluster на каждый namespace.
- Принятое решение по окружениям: закладываем `dev → stage → prod`, но пока работаем и публикуем только `dev`.
- Принятое решение по БД: CNPG кластер на каждый namespace (т.е. “одна БД на deployment” реализуем через отдельный CNPG per-namespace).
- Принятое решение по лендингам: один deployment на группу лендингов.
- Принятое решение по секретам: храним централизованно в `synestra-platform` (в т.ч. потому что сборка образов и часть CI сейчас живёт там).
- Dev-эргономика: добавлен “официальный” VS Code workspace `.vscode/web-core.code-workspace` и короткий runbook `docs/runbooks/runbook-dev.md`.
- Governance: добавлен `.github/CODEOWNERS`; владелец (первичный): `@NeoGrAIph` (NeoGrAIph@gmail.com).
- Enterprise patterns: генераторы и Changesets — отложены до выбора/анализа официальных шаблонов (чтобы не расходиться с recommended defaults).
- `synestra-platform`: ArgoCD корневое app-of-apps — `argocd/apps/synestra-platform.yaml` (синхронизирует `argocd/apps/*`), секреты применяются через `argocd/apps/infra-secrets.yaml` (SOPS plugin).
- `synestra-platform`: сейчас уже есть деплой Payload в namespace `webcore` — `argocd/apps/infra-payload.yaml` + `infra/webcore/payload/values*.yaml`.
- `synestra-platform`: `infra/webcore/payload/values.dev-hot.yaml` использует `hostPath` (локальный путь на ноде) и “install/build/start внутри Pod” — это dev-only костыль, который планируем заменить на Okteto.
- `synestra-platform`: CNPG оператор ставится `argocd/apps/infra-cloudnativepg.yaml`; текущий кластер для Payload живёт в namespace `databases` (`infra/databases/cloudnativepg/payload/cluster.yaml`) и использует bootstrap secret `payload-initdb-secret` (SOPS в `secrets/databases/payload-initdb-secret.yaml`).
- Okteto в `synestra-platform` пока не найден (по репозиторию нет упоминаний `okteto`) — инструмент выбран, но установка/интеграция ещё впереди.
- Рекомендуемая связка ArgoCD `synestra-platform` ↔ `web-core` (app-of-apps):
  - в `synestra-platform` добавляем один root Application на `web-core` (например `argocd/apps/web-core.yaml`), который синхронизирует `web-core/deploy/argocd/apps`;
  - внутри `web-core` живут ArgoCD Applications на каждый deployment (corporate/shop/saas/landings) и они ссылаются на `web-core/deploy/...` (Helm/Kustomize);
  - секреты остаются в `synestra-platform/secrets/**` (SOPS), а `web-core` оперирует только ссылками на Secret names/keys.
- Рекомендуемое владение CNPG per-namespace: оператор и “платформенные” дефолты — в `synestra-platform`, а CR’ы кластеров (Cluster/Backups/Pooler) для конкретных веб‑деплоев — в `web-core` (как часть GitOps-деплоя сайта), с ссылками на bootstrap/app Secret’ы, которые создаются в `synestra-platform`.
- Рекомендуемое место для “не‑секретов” (hosts/ресурсы/HPA/feature flags): хранить в `web-core` как values/overlays per-app/per-env; в `synestra-platform` держать только секреты и кластерные компоненты.
- Рекомендуемая фиксация toolchain для `web-core`: Node.js `22` (LTS) + pnpm через `packageManager` + `corepack` (синхронизировать с образами сборки в `synestra-platform`).
- Нейминг workspace‑пакетов в `web-core` фиксируем как scoped packages: `@synestra/<name>` (для `apps/*` и `packages/*`), чтобы стандартизировать импорты/`turbo --filter` и упростить генераторы/CI.

## Открытые вопросы

- Стратегия env‑переменных и “не‑секретов” для GitOps (dev/stage/prod): договориться о контракте ConfigMap/values, именах Secret’ов, правилах NEXT_PUBLIC_* и о том, как это отражать в `turbo` cache (чтобы не ловить неожиданные cache misses).
- Payload v3 + CNPG: стандартизировать миграции/seed/генерацию артефактов при деплое (Job/initContainer/Argo hook), чтобы деплой был детерминированным и безопасным.
- Стратегия стилизации `packages/ui`: Tailwind vs tokens/CSS vars vs (временные) inline‑styles, с учётом того что payload templates расходятся по Tailwind major (website: 3.x, ecommerce: 4.x).
- Shop/ecommerce: используем ли `@payloadcms/plugin-ecommerce` и Stripe (или иной провайдер), и какие требования это накладывает на ingress/webhooks, секреты и окружения.
- Какие ещё config packages нужны в `web-core` кроме TS/ESLint — определяем на основании требований актуальной версии Payload (и наших фактических потребностей CI/IDE).
- Вводим ли Turborepo generators (`@turbo/gen`) в `web-core`, или пока придерживаемся ручного подхода/официальных шаблонов Payload (вернуться к решению после анализа шаблонов).
- Вводим ли Changesets для versioning/changelog внутренних `packages/*` (даже без публикации в npm), или пока рано (вернуться к решению после анализа шаблонов).
