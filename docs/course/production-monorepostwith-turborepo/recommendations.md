# Рекомендации по репозиторию `web-core` на основе курса

Цель документа — последовательно фиксировать **проверяемые** рекомендации из курса `Production Monorepos with Turborepo` и маппить их на `web-core` (Next.js + Payload, self-host/k3s, GitOps/Argo CD в другом репо).

Формат для каждого урока:

- **Что говорит курс** (суть/тезисы).
- **Отражено ли это уже** в `docs/architecture/**` (или в текущей структуре).
- Ответ на вопрос: **«Есть рекомендации по правкам структуры репозитория?»**
- **Рекомендации** (конкретные, проверяемые действия).

---

## 0) `introduction.md`

**Что говорит курс**
- Учиться через “production patterns”: итеративно усложнять, деплоить часто, измерять (cache hits, время сборки), держать “реальные URL”.
- Курс строится вокруг monorepo с несколькими apps, shared packages, общими конфигами, тестами, оптимизацией пайплайна.
- Практика курса завязана на Node.js + pnpm и “one‑click deploy” на Vercel (и GitHub как source of truth).

**Отражено ли уже в `web-core`**
- Частично: принципы “монорепа для скорости, независимый деплой для безопасности”, `apps/*`, `packages/*`, `turbo.json`, `deploy/*` и docs уже присутствуют (см. `docs/architecture/architecture.md`).
- Версии инструментов уже зафиксированы: root `package.json` содержит `packageManager` (pnpm) и `engines.node`.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Зафиксировать “production‑workflow для self-host”: что означает “деплоить постоянно” в контексте k3s/ArgoCD (без Vercel) — в виде короткого runbook и CI‑контракта (image tag → values update → ArgoCD sync).
- Ввести “измеримые” проверки: стандартизированные команды `pnpm build/lint/test`, и (позже) отчёт о cache hit/miss в CI.
- Добавить удобный “лок” версии Node для разработчиков (`.nvmrc` или `.node-version`) и явно сослаться на него в `README.md`, чтобы локальная среда совпадала с `engines` и CI.

---

## 1) Section 1 — Monorepo Fundamentals

### 1.1 `1-understanding-monorepos.md`

**Что говорит курс**
- Базовый паттерн monorepo: `pnpm-workspace.yaml` (`apps/*`, `packages/*`), root `package.json` как координатор, `turbo.json` как оркестратор, apps содержат “обычные” скрипты фреймворка.
- Принцип: **root coordinates, apps implement**.
- Важность кэширования и remote cache (в курсе это “автоматически на Vercel”).
- “Стабильность окружения” через фиксацию версий Node/pnpm (через `engines` и `packageManager`).

**Отражено ли уже в `web-core`**
- Да: `pnpm-workspace.yaml`, root `package.json` (turbo‑скрипты), `turbo.json`, `apps/*` со стандартными next‑scripts, scoped‑нейминг `@synestra/*`.
- Да: root фиксирует версию pnpm (`packageManager`) и минимальную версию Node (`engines.node`).
- Частично задокументировано в `docs/architecture/repo-structure.md` и `docs/architecture/monorepo-package-contracts.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Да (точечные).

**Рекомендации**
- Зафиксировать “минимум в app”: обязательные файлы/директории и контракт env (уже частично есть в `apps/README.md`) и расширить это до “чеклиста нового приложения”.
- Формализовать поддержку remote caching вне Vercel: описать поддерживаемый вариант (self-host remote cache сервис / или корпоративный turbo cache) и требуемые env‑переменные в CI (без секретов в репо).
- Для DX: в документации dev‑окружения явно опираться на `pnpm <script>` (через root scripts), а установку `turbo --global` считать опциональной/необязательной (чтобы не разъезжались версии).

---

### 1.2 `2-monorepos-vs-polyrepos.md`

**Что говорит курс**
- Монорепа выигрывает там, где есть shared code и частые кросс‑изменения; ключевое преимущество — **атомарные изменения** и быстрый feedback (TS/линтер).
- Эвристика курса: если сомневаешься — **начни с монорепо** (разделить потом проще, чем качественно “склеить” несколько реп).

**Отражено ли уже в `web-core`**
- Да, концептуально отражено в `README.md` и `docs/architecture/architecture.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (это концептуальный урок), но есть рекомендации по процессу.

**Рекомендации**
- Держать shared‑код максимально “тонким” и переиспользуемым: UI/утилиты/конфиги отдельно от app‑специфики (уже выбран путь `packages/*`).
- Для снижения “координационного налога” внутри монорепы: вводить единые правила именования, версий, и централизованные конфиги (TS/ESLint/Prettier) без ручного копирования.

---

### 1.3 `3-turborepo-basics.md`

**Что говорит курс**
- Turborepo кэширует результаты задач по хэшу входов (код/зависимости/env/конфиги).
- `dependsOn: ["^build"]` обеспечивает правильный порядок сборки.
- `outputs` определяет артефакты, которые кэшируются.
- `globalDependencies` задаёт файлы, которые инвалидируют кеш “везде” (в примере курса: `.env.*local`).
- Полезные инструменты диагностики: `turbo build --dry-run` (видно, что будет выполняться) и хэши/outputs.

**Отражено ли уже в `web-core`**
- Да: `turbo.json` уже содержит `dependsOn` и `outputs` для `build`, а также `globalDependencies` для `.env*` и `.env.example` (у нас это шире, чем в примере курса).
- Частично задокументировано: `docs/architecture/tooling-turborepo.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Добавить документированный способ “посмотреть что побежит” перед CI/билдом: `turbo build --dry-run` / `--dry=json` как инструмент диагностики.
- Уточнить `outputs` для пакетов с `tsc` (`dist/**`) и убедиться, что pipeline реально кеширует то, что нужно (сейчас `dist/**` включён на уровне root `build.outputs`, что ок).
- На уровне CI (позже): включить remote caching и фиксировать метрики (cache hit/miss, время), чтобы репо оставалось быстрым на масштабе.
- Перепроверить корректность “инвалидации по env”: либо оставить текущий подход через `globalDependencies` (файлы `.env*`), либо дополнить `globalEnv`/`env` в `turbo.json` списком build‑влияющих переменных (если env задаётся не файлами, а CI/K8s‑секретами).

---

## 2) Section 2 — First Shared Package

### 2.1 `2-first-shared-package/1-add-features-page.md`

**Что говорит курс**
- Специально создать дублирование (inline‑компоненты/стили) в одном app, чтобы затем “почувствовать” ценность выделения shared‑пакета.

**Отражено ли это уже в `web-core`**
- Частично. В `web-core` уже есть `packages/ui`, но отсутствует демонстрационный “путь” выделения UI из app‑кода (у нас не было intentional duplication exercise как в курсе).

**Есть рекомендации по правкам структуры репозитория?**
- Нет (это скорее про учебный приём), но есть рекомендация по процессу.

**Рекомендации**
- Ввести в документации “алгоритм выделения общего”: сначала реализуем фичу в конкретном app, затем по чеклисту выносим переиспользуемые части в `packages/ui` / `packages/utils`.

---

### 2.2 `2-first-shared-package/2-create-ui-package.md`

**Что говорит курс**
- Создать `packages/ui` как workspace‑пакет и подключить его в apps через `workspace:*`.
- Экспортировать компоненты как subpath imports (в курсе: `@geniusgarage/ui/card`, `@geniusgarage/ui/button`) для более ясных “public APIs”.

**Отражено ли это уже в `web-core`**
- Да, частично: `packages/ui` есть и подключён к `apps/*` через `workspace:*`.
- Отличие: сейчас `@synestra/ui` экспортируется как единый entrypoint, а не subpath‑экспорты (и структура UI пока placeholder).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Стандартизировать “public API” UI пакета: решить, поддерживаем ли subpath‑экспорты (`@synestra/ui/button`) или только root‑экспорт (`@synestra/ui`), и зафиксировать решение в `packages/ui/README.md` (и в чеклисте нового app).
- Если выбираем subpath‑экспорты: описать правила структуры `packages/ui/src/*` и `exports` в `packages/ui/package.json`.

---

### 2.3 `2-first-shared-package/3-extract-card.md`

**Что говорит курс**
- Выделять повторяющиеся компоненты в `packages/ui`, затем переиспользовать из app.
- Показать эффект: изменение в shared‑компоненте отражается во всех местах сразу.

**Отражено ли это уже в `web-core`**
- Частично: `packages/ui` существует, но пока не содержит “реального” набора компонентов/паттернов, а также нет демонстрационного сценария “из app → в package”.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Для `web-core` важнее не “Card”, а принцип: определить минимальный набор базовых UI primitives (которые не привязаны к Tailwind major), и описать их назначение/границы.

---

### 2.4 `2-first-shared-package/4-extract-button-component.md`

**Что говорит курс**
- Добавлять компоненты в UI пакет, расширять библиотеку постепенно, держать единый стиль и единую точку правды.

**Отражено ли это уже в `web-core`**
- Частично: `Button` есть, но пока без тестов/договорённостей о вариантах/стилях.

**Есть рекомендации по правкам структуры репозитория?**
- Да (в сторону стандартизации UI пакета).

**Рекомендации**
- Зафиксировать контракт UI‑компонентов: “минимально‑необходимые пропсы”, совместимость между apps, и запрет на жёсткую привязку к Tailwind 3/4 до принятия решения (это уже отмечено в комментариях `packages/ui/src/index.ts` — перенести в docs).

---

### 2.5 `2-first-shared-package/5-deploy-web-app.md`

**Что говорит курс**
- Деплой app как независимой единицы и наблюдение Turborepo caching в CI.
- Remote caching (в курсе — Vercel) радикально ускоряет сборки при изменениях вне scope.

**Отражено ли это уже в `web-core`**
- Да по идее (независимые деплои), но у нас вместо Vercel — GitOps/ArgoCD, а remote cache ещё не определён.

**Есть рекомендации по правкам структуры репозитория?**
- Да (по документированию self-host аналога).

**Рекомендации**
- В `web-core` зафиксировать “эквивалент Vercel deploy” как контракт: immutable image tag → обновление `deploy/env/dev/*.yaml` → ArgoCD sync.
- Remote caching описать как отдельную инфраструктурную опцию (self-host), но специфику реализации держать в `synestra-platform`; в `web-core` — только требования/переменные/ожидаемое поведение.

---

## 3) Section 3 — Second App

### 3.1 `3-second-app/1-create-snippet-app.md`

**Что говорит курс**
- Добавить второй app с отдельным портом, подключить shared packages через `workspace:*`.

**Отражено ли это уже в `web-core`**
- Да: уже есть несколько apps (`corporate/ecommerce/experiments`) и договорённость по портам отражена в `docs/runbooks/runbook-dev.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (в целом уже выполнено), но есть рекомендации по стандартизации “шаблона app”.

**Рекомендации**
- Зафиксировать “минимум нового app” (скрипты, порт, env‑контракт, `src/app/**`, `src/payload.config.ts`, `src/migrations/`) как чеклист (уже частично описано в `apps/README.md`).

---

### 3.2 `3-second-app/2-build-snippet-list-page.md`

**Что говорит курс**
- Переиспользовать UI компоненты во втором app.
- Проверить hot reload и поведение при изменениях в shared packages.

**Отражено ли это уже в `web-core`**
- Частично: apps уже зависят от `@synestra/ui`, но “горячий” UX при изменении shared пакетов не зафиксирован как стандарт (и зависит от Next/pnpm/трансформации workspace‑пакетов).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Определить и документировать, как именно мы хотим добиваться “hot reload across packages” для Next 15 + workspace packages (например, через `transpilePackages` в `next.config.mjs`, единый паттерн для всех apps).

---

### 3.3 `3-second-app/3-add-codeblock-snippetcard.md`

**Что говорит курс**
- Развивать UI пакет: композиция компонентов (SnippetCard из Card+CodeBlock), экспортирование через public API.

**Отражено ли это уже в `web-core`**
- Пока нет: UI пакет минимальный, компонентной библиотеки нет.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Ввести правила композиции UI компонентов и структуру файлов (например: primitives vs composed) так, чтобы это не мешало интеграции Payload templates.

---

### 3.4 `3-second-app/4-snippet-creation-modal.md`

**Что говорит курс**
- App‑специфичная логика остаётся в app; UI‑компоненты — в packages.

**Отражено ли это уже в `web-core`**
- Концептуально да (разделение apps/packages), но ещё не закреплено практикой на “реальной” функциональности.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (скорее про дисциплину границ), но стоит зафиксировать правило.

**Рекомендации**
- Зафиксировать правило “не тянуть app‑специфичное в shared package без причин”: описать критерии выноса (переиспользование ≥2 apps, стабильный API, отсутствие зависимости от Payload config конкретного сайта).

---

### 3.5 `3-second-app/5-deploy-both-apps.md`

**Что говорит курс**
- Независимые деплои для apps из одной монорепы; селективные билды.

**Отражено ли это уже в `web-core`**
- Да в архитектуре (`deploy/argocd/apps/dev/*`), но ещё не “подключено” реально (placeholders).

**Есть рекомендации по правкам структуры репозитория?**
- Да (закрепить контракт селективного билда/деплоя).

**Рекомендации**
- Держать “один deployment = один ArgoCD Application”; для `experiments` — явно исключать из GitOps.

---

## 4) Section 4 — Shared Configs & Utils

### 4.1 `4-shared-configs-and-utils/1-extract-shared-configs.md`

**Что говорит курс**
- Выносить конфиги в отдельные пакеты (`typescript-config`, `eslint-config`).
- Apps должны extend/import эти конфиги напрямую, чтобы избежать drift.

**Отражено ли это уже в `web-core`**
- Да: `packages/typescript-config` и `packages/eslint-config` существуют и используются как единый источник (apps расширяют `@synestra/typescript-config/nextjs.json`, пакеты — `@synestra/typescript-config/base.json`).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Держать один механизм расширения TS конфигов (apps → `nextjs.json`, packages → `base.json`) и не возвращаться к копированию/дрейфу настроек.

---

### 4.2 `4-shared-configs-and-utils/2-add-shared-utils.md`

**Что говорит курс**
- Создать `packages/utils` для чистых утилит (без привязки к UI/Next) и переиспользовать между apps.

**Отражено ли это уже в `web-core`**
- Частично: `packages/utils` есть, но пока без наполнения и без “контракта” какие утилиты допустимы.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Зафиксировать границы `@synestra/utils`: только pure functions (без DOM/Next/Payload), и добавить минимальный набор утилит по мере реальных потребностей (не преждевременно).

---

### 4.3 `4-shared-configs-and-utils/3-update-turborepo-pipeline.md`

**Что говорит курс**
- Добавить build‑scripts в packages, чтобы turbo строил граф (packages → apps).
- Использовать `turbo build --dry` для диагностики.

**Отражено ли это уже в `web-core`**
- Да: packages имеют `build` скрипты, а `turbo.json` уже задаёт `dependsOn: ["^build"]` и `outputs`.
- Отличие: в курсе часто используется `tsc --noEmit` для быстрых “package builds”, а у нас tsc настроен на генерацию `dist`.

**Есть рекомендации по правкам структуры репозитория?**
- Да (уточнить, что мы считаем “build” для packages).

**Рекомендации**
- Определить, что `build` для shared packages означает в `web-core`:
  - вариант A: “typecheck only” (`tsc --noEmit`) для скорости;
  - вариант B: “emit dist” для публикации/потребления как артефакта.
  Зафиксировать один вариант (или развести на `build` и `build:dist`) и описать в docs.

---

## 5) Section 5 — Testing

### 5.1 `5-testing/1-set-up-vitest.md`

**Что говорит курс**
- Добавить Vitest + RTL + jsdom в `packages/ui`, настроить `vitest.config.ts` и `src/test/setup.ts`.

**Отражено ли это уже в `web-core`**
- Да: Vitest + RTL + jsdom настроены в `packages/ui` (есть `vitest.config.ts`, `src/test/setup.ts`, `scripts.test`).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Ввести тестовый контур в `packages/ui` первым (как в курсе), затем постепенно расширять на другие пакеты (utils/plugins) при необходимости.

---

### 5.2 `5-testing/2-write-component-tests.md`

**Что говорит курс**
- Писать тесты на UI компоненты, чтобы изменения shared UI не ломали все apps.

**Отражено ли это уже в `web-core`**
- Да: добавлены базовые UI‑тесты (как минимум для `Button`) и включены в `pnpm test` через Turborepo.

**Есть рекомендации по правкам структуры репозитория?**
- Нет по структуре, но да по обязательным скриптам `test` в ключевых packages.

**Рекомендации**
- Для пакетов, которые являются “точкой отказа” (UI), сделать `test` обязательным (и запускать его в turbo pipeline).

---

### 5.3 `5-testing/3-configure-turborepo-tests.md`

**Что говорит курс**
- Добавить `test` task в `turbo.json` и кешировать результаты (coverage outputs).

**Отражено ли это уже в `web-core`**
- Частично: `turbo.json` содержит `test` task (с `outputs: []`), и `packages/ui` имеет `scripts.test`. Coverage‑артефакты пока не генерируются.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Привести `turbo test` к “рабочему состоянию”: добавить `test` хотя бы в `@synestra/ui`, и только потом расширять дальше.

---

### 5.4 `5-testing/4-test-caching.md`

**Что говорит курс**
- Понимать инвалидацию кеша (source/tests/config/скрипты).
- Remote caching усиливает эффект в CI/команде.

**Отражено ли это уже в `web-core`**
- На уровне понимания — да (в docs уже есть упоминания remote caching), но практическая настройка не сделана.

**Есть рекомендации по правкам структуры репозитория?**
- Да (план/документация).

**Рекомендации**
- Свести правила “что инвалидирует кеш” в один документ (как минимум: `.env.*local`, `turbo.json`, root `package.json`) и учитывать это при планировании изменений.

---

## Примечание: отсутствующий раздел про env vars

В конце `5-testing/4-test-caching.md` курс анонсирует следующий раздел “Environment Variables”, но в сохранённом наборе материалов `docs/course/production-monorepostwith-turborepo/**` **нет** отдельной секции/уроков про env vars.

Для `web-core` это критично (Payload/Next + dev/stage/prod + GitOps), поэтому стратегию env‑переменных и их валидации нужно сформировать отдельно, опираясь на:

- исследование Payload templates: `docs/research/templates-research.md` и `docs/research/templates/*`;
- наши ограничения “никаких секретов в репо” и split ответственности с `synestra-platform`.

---

## 6) Section 6 — Pipeline Optimization

### 6.1 `6-pipeline-optimization/1-github-actions.md`

**Что говорит курс**
- CI должен запускать `turbo build lint test` одной командой, чтобы turbo распараллеливал.
- Настройка pnpm + node caching.

**Отражено ли это уже в `web-core`**
- Да: добавлен референсный workflow CI в `.github/workflows/ci.yml` (при этом основной CI по‑прежнему может жить в `synestra-platform`).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Добавить “референсный” CI workflow (OSS) внутри `web-core` как документацию/страховку (даже если основной CI в GitLab).

---

### 6.2 `6-pipeline-optimization/2-filtering-git-based.md`

**Что говорит курс**
- Использовать `--filter=[origin/main]` в CI для инкрементальных билдов.
- Требование `fetch-depth: 0` для git‑сравнения.

**Отражено ли это уже в `web-core`**
- Частично: `pnpm --filter` используется в docs/runbook; CI‑фильтрации нет.

**Есть рекомендации по правкам структуры репозитория?**
- Да (как часть CI‑контракта).

**Рекомендации**
- Зафиксировать в документации “селективный билд” как стандарт для CI: на PR — фильтр, на main — полный прогон (или наоборот, по политике).

---

### 6.3 `6-pipeline-optimization/3-remote-caching.md`

**Что говорит курс**
- Remote cache делит артефакты между dev и CI; токены/права нужно ограничивать.
- `.turbo/config.json` не коммитить.

**Отражено ли это уже в `web-core`**
- Частично: `.turbo/` уже игнорируется; но выбранный remote cache (Vercel или self-host) не закреплён.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Для `web-core` (self-host) выбрать эквивалент “Vercel remote cache” (например, self-host turbo remote cache) и описать только интерфейс/переменные; секреты и развёртывание — в `synestra-platform`.

---

## 7) Section 7 — Scaling to Multiple Apps

### 7.1 `7-add-third-app/1-add-docs-app.md`

**Что говорит курс**
- Добавление третьего app должно быть “дешёвым”: reuse shared packages/configs.
- В примере используется `NEXT_PUBLIC_*` env и (в курсе) “env validation” как отдельный слой.

**Отражено ли это уже в `web-core`**
- Да частично: уже есть несколько apps и shared packages.
- Env validation у нас точечная (проверки в payload.config.ts), но нет общей стратегии.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Ввести стандарт для env‑контракта на уровне каждого app: `.env.example` + проверка “required in production” (для Payload и Next runtime), не смешивая секреты/несекреты.

---

### 7.2 `7-add-third-app/2-deploy-all-apps.md`

**Что говорит курс**
- Независимые деплои для 3 apps; изменение shared package вызывает ребилд всех зависимых apps.

**Отражено ли это уже в `web-core`**
- Да по архитектуре GitOps (один Application на deployment), но “реальные URL/домены” и CI‑связка пока placeholders.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Для каждого app держать отдельные values (как сейчас) и явно документировать “что считается изменением, требующим деплоя зависимых apps” (shared packages).

---

### 7.3 `7-add-third-app/3-multi-app-development.md`

**Что говорит курс**
- Практики multi-app dev: `pnpm dev`, `pnpm --filter`, порты, VSCode workspace.

**Отражено ли это уже в `web-core`**
- Да: порты и команды описаны в `docs/runbooks/runbook-dev.md`, VSCode workspace уже есть (`.vscode/web-core.code-workspace`).

**Есть рекомендации по правкам структуры репозитория?**
- Нет (в целом уже выполнено), кроме возможной детализации.

**Рекомендации**
- Держать “таблицу портов” и стандарт `pnpm --filter` команд в одном месте (уже есть) и обновлять при добавлении app.

---

## 8) Section 8 — Enterprise Patterns

### 8.1 `8-enterprise-patterns/1-turborepo-generators.md`

**Что говорит курс**
- Автоматизировать шаблоны компонент/пакетов через `@turbo/gen` (plop‑подобные генераторы).

**Отражено ли это уже в `web-core`**
- Частично: есть директория `turbo/` и заготовка под generators, но генераторы не внедрены как стандарт.

**Есть рекомендации по правкам структуры репозитория?**
- Да (опционально, позже).

**Рекомендации**
- Ввести генераторы после стабилизации структуры `packages/ui` и появления тестового контура (иначе генератор будет плодить неустойчивый шаблон).

---

### 8.2 `8-enterprise-patterns/2-changesets-versioning.md`

**Что говорит курс**
- Использовать Changesets для версионирования shared packages и генерации changelog.

**Отражено ли это уже в `web-core`**
- Нет (и есть вопрос применимости, т.к. пакеты не публикуются в npm).

**Есть рекомендации по правкам структуры репозитория?**
- Да (как опциональный инструмент governance).

**Рекомендации**
- Рассмотреть Changesets как внутренний механизм “release notes” для shared packages даже без npm‑публикации; решение отложить до момента, когда появится реальная потребность в отслеживании изменений `packages/*`.

---

### 8.3 `8-enterprise-patterns/3-code-governance.md`

**Что говорит курс**
- CODEOWNERS + branch protection как базовая governance практика.

**Отражено ли это уже в `web-core`**
- Да: `.github/CODEOWNERS` присутствует и отражает владение областями.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (минимум уже есть).

**Рекомендации**
- По мере роста: уточнить ownership по “критичным” областям (deploy/tooling/shared packages) и поддерживать актуальность.

---

### 8.4 `8-enterprise-patterns/4-next-forge-patterns.md`

**Что говорит курс**
- next-forge как “витрина” production‑паттернов: более тонкие package boundaries, Biome, security headers, rate limiting, аналитика/наблюдаемость, более сложный turbo pipeline.

**Отражено ли это уже в `web-core`**
- Частично: структура apps/packages уже есть, но прод‑паттерны безопасности/observability не внедрены.

**Есть рекомендации по правкам структуры репозитория?**
- Да (как источник идей, не как обязательный blueprint).

**Рекомендации**
- Использовать next-forge как “каталог идей”, но переносить только то, что не конфликтует с self-host/k3s и Payload:
  - security headers/CSP как стандарт для Next apps,
  - более строгие границы пакетов (по доменам) — по мере роста,
  - оценить Biome как альтернативу ESLint+Prettier (но не вводить до стабилизации текущего tooling).
