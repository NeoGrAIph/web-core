# Рекомендации по репозиторию `web-core` на основе курса

Цель документа — последовательно фиксировать **проверяемые** рекомендации из курса `Production Monorepos with Turborepo` и маппить их на `web-core` (Next.js + Payload, self-host/k3s, GitOps/Argo CD в другом репо).

Формат для каждого урока:

- **Что говорит курс** (суть/тезисы).
- **Отражено ли это уже** в `docs/architecture/**` (или в текущей структуре).
- Ответ на вопрос: **«Есть рекомендации по правкам структуры репозитория?»**
- **Рекомендации** (конкретные, проверяемые действия).

---

## 0) `introduction.md`

**Что говорит курс**
- Учиться через “production patterns”: итеративно усложнять, деплоить часто, измерять (cache hits, время сборки), держать “реальные URL”.
- Курс строится вокруг monorepo с несколькими apps, shared packages, общими конфигами, тестами, оптимизацией пайплайна.
- Практика курса завязана на Node.js + pnpm и “one‑click deploy” на Vercel (и GitHub как source of truth).

**Отражено ли уже в `web-core`**
- Частично: принципы “монорепа для скорости, независимый деплой для безопасности”, `apps/*`, `packages/*`, `turbo.json`, `deploy/*` и docs уже присутствуют (см. `docs/architecture/architecture.md`).
- Версии инструментов уже зафиксированы: root `package.json` содержит `packageManager` (pnpm) и `engines.node`.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Зафиксировать “production‑workflow для self-host”: что означает “деплоить постоянно” в контексте k3s/ArgoCD (без Vercel) — в виде короткого runbook и CI‑контракта (image tag → values update → ArgoCD sync).
- Ввести “измеримые” проверки: стандартизированные команды `pnpm build/lint/test`, и (позже) отчёт о cache hit/miss в CI.
- Добавить удобный “лок” версии Node для разработчиков (`.nvmrc` или `.node-version`) и явно сослаться на него в `README.md`, чтобы локальная среда совпадала с `engines` и CI.

---

## 1) Section 1 — Monorepo Fundamentals

### 1.1 `1-understanding-monorepos.md`

**Что говорит курс**
- Базовый паттерн monorepo: `pnpm-workspace.yaml` (`apps/*`, `packages/*`), root `package.json` как координатор, `turbo.json` как оркестратор, apps содержат “обычные” скрипты фреймворка.
- Принцип: **root coordinates, apps implement**.
- Важность кэширования и remote cache (в курсе это “автоматически на Vercel”).
- “Стабильность окружения” через фиксацию версий Node/pnpm (через `engines` и `packageManager`).

**Отражено ли уже в `web-core`**
- Да: `pnpm-workspace.yaml`, root `package.json` (turbo‑скрипты), `turbo.json`, `apps/*` со стандартными next‑scripts, scoped‑нейминг `@synestra/*`.
- Да: root фиксирует версию pnpm (`packageManager`) и минимальную версию Node (`engines.node`).
- Частично задокументировано в `docs/architecture/repo-structure.md` и `docs/architecture/monorepo-package-contracts.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Да (точечные).

**Рекомендации**
- Зафиксировать “минимум в app”: обязательные файлы/директории и контракт env (уже частично есть в `apps/README.md`) и расширить это до “чеклиста нового приложения”.
- Формализовать поддержку remote caching вне Vercel: описать поддерживаемый вариант (self-host remote cache сервис / или корпоративный turbo cache) и требуемые env‑переменные в CI (без секретов в репо).
- Для DX: в документации dev‑окружения явно опираться на `pnpm <script>` (через root scripts), а установку `turbo --global` считать опциональной/необязательной (чтобы не разъезжались версии).

---

### 1.2 `2-monorepos-vs-polyrepos.md`

**Что говорит курс**
- Монорепа выигрывает там, где есть shared code и частые кросс‑изменения; ключевое преимущество — **атомарные изменения** и быстрый feedback (TS/линтер).
- Эвристика курса: если сомневаешься — **начни с монорепо** (разделить потом проще, чем качественно “склеить” несколько реп).

**Отражено ли уже в `web-core`**
- Да, концептуально отражено в `README.md` и `docs/architecture/architecture.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (это концептуальный урок), но есть рекомендации по процессу.

**Рекомендации**
- Держать shared‑код максимально “тонким” и переиспользуемым: UI/утилиты/конфиги отдельно от app‑специфики (уже выбран путь `packages/*`).
- Для снижения “координационного налога” внутри монорепы: вводить единые правила именования, версий, и централизованные конфиги (TS/ESLint/Prettier) без ручного копирования.

---

### 1.3 `3-turborepo-basics.md`

**Что говорит курс**
- Turborepo кэширует результаты задач по хэшу входов (код/зависимости/env/конфиги).
- `dependsOn: ["^build"]` обеспечивает правильный порядок сборки.
- `outputs` определяет артефакты, которые кэшируются.
- `globalDependencies` задаёт файлы, которые инвалидируют кеш “везде” (в примере курса: `.env.*local`).
- Полезные инструменты диагностики: `turbo build --dry-run` (видно, что будет выполняться) и хэши/outputs.

**Отражено ли уже в `web-core`**
- Да: `turbo.json` уже содержит `dependsOn` и `outputs` для `build`, а также `globalDependencies` для `.env*` и `.env.example` (у нас это шире, чем в примере курса).
- Частично задокументировано: `docs/architecture/tooling-turborepo.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Добавить документированный способ “посмотреть что побежит” перед CI/билдом: `turbo build --dry-run` / `--dry=json` как инструмент диагностики.
- Уточнить `outputs` для пакетов с `tsc` (`dist/**`) и убедиться, что pipeline реально кеширует то, что нужно (сейчас `dist/**` включён на уровне root `build.outputs`, что ок).
- На уровне CI (позже): включить remote caching и фиксировать метрики (cache hit/miss, время), чтобы репо оставалось быстрым на масштабе.
- Перепроверить корректность “инвалидации по env”: либо оставить текущий подход через `globalDependencies` (файлы `.env*`), либо дополнить `globalEnv`/`env` в `turbo.json` списком build‑влияющих переменных (если env задаётся не файлами, а CI/K8s‑секретами).

---

## 2) Section 2 — First Shared Package

### 2.1 `2-first-shared-package/1-add-features-page.md`

**Что говорит курс**
- Специально создать дублирование в одном app: 6 одинаковых “карточек” (inline JSX + inline styles) и повторение UI‑фрагментов (навигация).
- Цель — на собственном опыте увидеть цену копипаста, чтобы затем было очевидно, зачем нужен shared package.

**Отражено ли это уже в `web-core`**
- Частично: в `web-core` уже есть `packages/ui`, но “учебный приём” intentional duplication не закреплён как метод (как именно решаем, что выносить в shared).

**Есть рекомендации по правкам структуры репозитория?**
- Нет (это скорее про учебный приём), но есть рекомендация по процессу.

**Рекомендации**
- Ввести в документации “алгоритм выделения общего”: сначала реализуем фичу в конкретном app, затем по чеклисту выносим переиспользуемые части в `packages/ui` / `packages/utils`.
- Явно зафиксировать границу: app‑код может временно содержать “локальные” компоненты, но их публичное переиспользование начинается только после выноса/стандартизации в package (иначе появится второй неформальный “shared” слой).

---

### 2.2 `2-first-shared-package/2-create-ui-package.md`

**Что говорит курс**
- Создать `packages/ui` как workspace‑пакет и подключить его в apps через `workspace:*`.
- Экспортировать компоненты как subpath imports (в курсе: `@geniusgarage/ui/card`, `@geniusgarage/ui/button`) для более ясных “public APIs”.
- Держать React как `peerDependencies`, а типы/TS — как `devDependencies` пакета, чтобы избежать “двух React”.
- Подготовить TS‑конфиг пакета под JSX/типизацию.

**Отражено ли это уже в `web-core`**
- Да, частично: `packages/ui` есть и подключён к `apps/*` через `workspace:*`.
- Отличие: сейчас `@synestra/ui` экспортируется как единый entrypoint, а не subpath‑экспорты (и структура UI пока placeholder).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Стандартизировать “public API” UI пакета: решить, поддерживаем ли subpath‑экспорты (`@synestra/ui/button`) или только root‑экспорт (`@synestra/ui`), и зафиксировать решение в `packages/ui/README.md` (и в чеклисте нового app).
- Если выбираем subpath‑экспорты: описать правила структуры `packages/ui/src/*` и `exports` в `packages/ui/package.json`.
- Проверить/закрепить правило peer deps для UI: React/Next‑совместимые диапазоны и запрет на прямые `dependencies` для React (чтобы не ловить runtime‑конфликты).

---

### 2.3 `2-first-shared-package/3-extract-card.md`

**Что говорит курс**
- Выделять повторяющиеся компоненты в `packages/ui`, затем переиспользовать из app.
- Показать эффект: изменение в shared‑компоненте отражается во всех местах сразу.
- Закрепить паттерн экспорта: `package.json.exports` + явный import path (`@.../ui/card`).
- Утверждение курса: в Next.js 15+ с Turbopack локальные workspace packages “работают автоматически” и `transpilePackages` обычно не нужен.

**Отражено ли это уже в `web-core`**
- Частично: `packages/ui` существует, но пока не содержит “реального” набора компонентов/паттернов, а также нет демонстрационного сценария “из app → в package”.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Для `web-core` важнее не “Card”, а принцип: определить минимальный набор базовых UI primitives (которые не привязаны к Tailwind major), и описать их назначение/границы.
- Для Next.js: не принимать “transpilePackages не нужен” как аксиому — зафиксировать канон для `web-core`: либо всегда использовать `transpilePackages` для workspace‑пакетов в Next apps, либо документированно отказаться, но с проверкой `pnpm --filter <app> build` на реальных пакетах (чтобы не поймать прод‑расхождение dev/build).

---

### 2.4 `2-first-shared-package/4-extract-button-component.md`

**Что говорит курс**
- Добавлять компоненты в UI пакет, расширять библиотеку постепенно, держать единый стиль и единую точку правды.
- Делать компоненты более гибкими через параметры (пример: `variant`), а не через копирование/ветвление на местах.

**Отражено ли это уже в `web-core`**
- Частично: `Button` есть, но пока без тестов/договорённостей о вариантах/стилях.

**Есть рекомендации по правкам структуры репозитория?**
- Да (в сторону стандартизации UI пакета).

**Рекомендации**
- Зафиксировать контракт UI‑компонентов: “минимально‑необходимые пропсы”, совместимость между apps, и запрет на жёсткую привязку к Tailwind 3/4 до принятия решения (это уже отмечено в комментариях `packages/ui/src/index.ts` — перенести в docs).
- Стандартизировать паттерн “варианты”: либо `variant` проп + tokens/variants, либо иной каноничный подход (чтобы каждое приложение не придумывала свой формат вариантов).

---

### 2.5 `2-first-shared-package/5-deploy-web-app.md`

**Что говорит курс**
- Деплой app как независимой единицы и наблюдение Turborepo caching в CI.
- Remote caching (в курсе — Vercel) радикально ускоряет сборки при изменениях вне scope.
- Важный практический приём: деплоить не “весь монорепо”, а **фильтровать** сборку (`turbo build --filter=...`), чтобы CI не тратил время на нерелевантные пакеты.

**Отражено ли это уже в `web-core`**
- Да по идее (независимые деплои), но у нас вместо Vercel — GitOps/ArgoCD, а remote cache ещё не определён.

**Есть рекомендации по правкам структуры репозитория?**
- Да (по документированию self-host аналога).

**Рекомендации**
- В `web-core` зафиксировать “эквивалент Vercel deploy” как контракт: immutable image tag → обновление `deploy/env/dev/*.yaml` → ArgoCD sync.
- Remote caching описать как отдельную инфраструктурную опцию (self-host), но специфику реализации держать в `synestra-platform`; в `web-core` — только требования/переменные/ожидаемое поведение.
- Привязать “filtered builds” к нашему контуру: для каждого app иметь каноничную команду сборки/пакетирования (`turbo build --filter=@synestra/<app>` и/или `turbo prune --scope=...`) и ссылаться на неё в runbooks/CI‑контракте.

---

## 3) Section 3 — Second App

### 3.1 `3-second-app/1-create-snippet-app.md`

**Что говорит курс**
- Добавить второй app (`apps/snippet-manager`), чтобы доказать, что shared packages работают не “в теории”, а между несколькими приложениями.
- Scaffold через `create-next-app`, затем:
  - namespaced имя пакета,
  - dev‑порт 3001 (чтобы параллельно с 3000),
  - зависимость на `packages/ui` через `workspace:*`,
  - запуск обоих apps через единый `pnpm dev` (Turborepo).

**Отражено ли это уже в `web-core`**
- Да: уже есть несколько apps (`corporate/ecommerce/experiments`) и договорённость по портам отражена в `docs/runbooks/runbook-dev.md`.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (в целом уже выполнено), но есть рекомендации по стандартизации “шаблона app”.

**Рекомендации**
- Зафиксировать “минимум нового app” (скрипты, порт, env‑контракт, `src/app/**`, `src/payload.config.ts`, `src/migrations/`) как чеклист (уже частично описано в `apps/README.md`).
- Для `web-core`: отдельно канонизировать “скелет Next+Payload app” vs “чистого Next app” (docs/marketing) — в курсе второй app без Payload, у нас это требует явного решения.

---

### 3.2 `3-second-app/2-build-snippet-list-page.md`

**Что говорит курс**
- Переиспользовать UI компоненты во втором app.
- Проверить hot reload и поведение при изменениях в shared packages.
- Важный акцент: при правке `packages/ui` оба apps должны hot‑reload одновременно (DX‑“магия” workspace).
- В уроке появляется смешение стилизации: часть UI остаётся на inline styles, но layout делается Tailwind‑классами.

**Отражено ли это уже в `web-core`**
- Частично: apps уже зависят от `@synestra/ui`, но “горячий” UX при изменении shared пакетов не зафиксирован как стандарт (и зависит от Next/pnpm/трансформации workspace‑пакетов).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Определить и документировать, как именно мы хотим добиваться “hot reload across packages” для Next 15 + workspace packages (например, через `transpilePackages` в `next.config.mjs`, единый паттерн для всех apps).
- Для `web-core`: выбрать и закрепить единый подход к стилям в shared UI (tokens/variants, Tailwind, CSS modules и т.п.) и избегать “случайного” микса Tailwind+inline без причин (иначе переиспользование между apps дорожает).

---

### 3.3 `3-second-app/3-add-codeblock-snippetcard.md`

**Что говорит курс**
- Развивать UI пакет: композиция компонентов (SnippetCard из Card+CodeBlock), экспортирование через public API.
 - Строить библиотеку через “primitives → composed”: `SnippetCard` переиспользует `Card` и `CodeBlock`, а не копирует их.
 - Усиливается важность корректных `exports` (subpath), иначе apps не смогут импортировать новые компоненты стабильными путями.

**Отражено ли это уже в `web-core`**
- Пока нет: UI пакет минимальный, компонентной библиотеки нет.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Ввести правила композиции UI компонентов и структуру файлов (например: primitives vs composed) так, чтобы это не мешало интеграции Payload templates.
- Зафиксировать правило зависимостей: composed компоненты могут зависеть от primitives, но не наоборот (для предотвращения циклов и роста связности).
- Если выбран стиль subpath exports: добавление UI‑компонента должно включать обновление `package.json.exports` (DoD) и проверку импорта из app.

---

### 3.4 `3-second-app/4-snippet-creation-modal.md`

**Что говорит курс**
- App‑специфичная логика остаётся в app; UI‑компоненты — в packages.
 - Добавить интерактивность: `useState` для списка сущностей, видимости модалки и формы; модалка собирается из shared UI‑атомов (`Button`).

**Отражено ли это уже в `web-core`**
- Концептуально да (разделение apps/packages), но ещё не закреплено практикой на “реальной” функциональности.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (скорее про дисциплину границ), но стоит зафиксировать правило.

**Рекомендации**
- Зафиксировать правило “не тянуть app‑специфичное в shared package без причин”: описать критерии выноса (переиспользование ≥2 apps, стабильный API, отсутствие зависимости от Payload config конкретного сайта).
- Для `web-core`: дополнить критерии “Payload‑специфики” — если UI компонент начинает импортировать Payload types/config, это сигнал, что ему место в app‑локальном слое или в отдельном `@synestra/payload-*` пакете, а не в `@synestra/ui`.

---

### 3.5 `3-second-app/5-deploy-both-apps.md`

**Что говорит курс**
- Независимые деплои для apps из одной монорепы; селективные билды.
 - Практика: второй app деплоится отдельной “единицей” из того же репозитория; ключ — filtered build (`turbo build --filter=...`).
 - (Опционально) оптимизация: игнорировать rebuild, если изменения вне scope app и его shared зависимостей.

**Отражено ли это уже в `web-core`**
- Да в архитектуре (`deploy/argocd/apps/dev/*`), но ещё не “подключено” реально (placeholders).

**Есть рекомендации по правкам структуры репозитория?**
- Да (закрепить контракт селективного билда/деплоя).

**Рекомендации**
- Держать “один deployment = один ArgoCD Application”; для `experiments` — явно исключать из GitOps.
- Зафиксировать для каждого app каноничный “scope сборки/пакетирования”: `turbo build --filter=@synestra/<app>` и/или `turbo prune --scope=@synestra/<app> --docker` (если используем уменьшение контекста).
- Vercel‑идею “Ignored Build Step” перенести в platform CI как “affected builds” (например, через `turbo --dry-run`) — в `web-core` держать только контракт/команды диагностики.

---

## 4) Section 4 — Shared Configs & Utils

### 4.1 `4-shared-configs-and-utils/1-extract-shared-configs.md`

**Что говорит курс**
- Выносить конфиги в отдельные пакеты (`typescript-config`, `eslint-config`).
- Apps должны extend/import эти конфиги напрямую, чтобы избежать drift.
- “Один инструмент — один пакет”: конфиги модульны и композиционны (base vs nextjs).
- ESLint в курсе — flat config (`eslint.config.mjs`), импортируемый из shared пакета.
- Проверка работоспособности правилами: намеренно ввести ошибку (unused var) и убедиться, что shared правило ловит её одинаково во всех apps.
- Отдельно упоминается альтернатива: Biome как быстрый unified toolchain (не внедряется в курсе, но отмечается как опция при росте монорепо).

**Отражено ли это уже в `web-core`**
- Да: `packages/typescript-config` и `packages/eslint-config` существуют и используются как единый источник (apps расширяют `@synestra/typescript-config/nextjs.json`, пакеты — `@synestra/typescript-config/base.json`).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Держать один механизм расширения TS конфигов (apps → `nextjs.json`, packages → `base.json`) и не возвращаться к копированию/дрейфу настроек.
- Явно закрепить правило “инструмент‑конфиг = отдельный пакет” (у нас уже так сделано) и в чеклисте нового app требовать:
  - `extends @synestra/typescript-config/nextjs.json`
  - импорт shared eslint‑конфига (flat).
- Отдельным пунктом в docs: когда (и почему) рассматривать Biome вместо ESLint+Prettier (например, при росте монорепо и замедлении lint > N секунд).

---

### 4.2 `4-shared-configs-and-utils/2-add-shared-utils.md`

**Что говорит курс**
- Создать `packages/utils` для чистых утилит (без привязки к UI/Next) и переиспользовать между apps.
- Принцип “monorepo не только про UI”: общий код может быть любым (utils, core‑логика, валидаторы).
- Пример критерия: утилиты — pure functions (Intl.DateTimeFormat, slugify, truncate, validateEmail).
- В уроке демонстрируется усиление типизации: перевод `createdAt` из `string` в `Date` и форматирование через shared `formatDate`.

**Отражено ли это уже в `web-core`**
- Частично: `packages/utils` есть, но пока без наполнения и без “контракта” какие утилиты допустимы.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Зафиксировать границы `@synestra/utils`: только pure functions (без DOM/Next/Payload), и добавить минимальный набор утилит по мере реальных потребностей (не преждевременно).
- Для `web-core`: отдельно договориться о “доменном” shared слое (если появится): утилиты ≠ доменная логика. Если начинаем делить бизнес‑правила — это уже кандидат в отдельный `packages/core` (или `packages/domain-*`), а не в utils.

---

### 4.3 `4-shared-configs-and-utils/3-update-turborepo-pipeline.md`

**Что говорит курс**
- Добавить build‑scripts в packages, чтобы turbo строил граф (packages → apps).
- Использовать `turbo build --dry` для диагностики.
- Ключевая идея: Turbo “не должен угадывать”, а должен иметь явные task‑правила (`dependsOn: ["^build"]`, `^lint`).
- В курсе build для `packages/ui`/`packages/utils` = `tsc --noEmit` (typecheck как “build”), а config‑пакеты build не требуют (статические файлы).
- Показан полезный паттерн: изменение файла в зависимости → rebuild только затронутого app (селективная инвалидация кеша по графу).

**Отражено ли это уже в `web-core`**
- Да: packages имеют `build` скрипты, а `turbo.json` уже задаёт `dependsOn: ["^build"]` и `outputs`.
- Отличие: в курсе часто используется `tsc --noEmit` для быстрых “package builds”, а у нас tsc настроен на генерацию `dist`.

**Есть рекомендации по правкам структуры репозитория?**
- Да (уточнить, что мы считаем “build” для packages).

**Рекомендации**
- Определить, что `build` для shared packages означает в `web-core`:
  - вариант A: “typecheck only” (`tsc --noEmit`) для скорости;
  - вариант B: “emit dist” для публикации/потребления как артефакта.
  Зафиксировать один вариант (или развести на `build` и `build:dist`) и описать в docs.
- Дополнить DoD для новых packages: если пакет участвует в графе (не только конфиг), у него должен быть минимум `scripts.build` и (желательно) `scripts.lint`, иначе turbo‑пайплайн деградирует в “частично управляемый”.

---

## 5) Section 5 — Testing

### 5.1 `5-testing/1-set-up-vitest.md`

**Что говорит курс**
- Добавить Vitest + RTL + jsdom в `packages/ui`, настроить `vitest.config.ts` и `src/test/setup.ts`.
- Разделяет “CI‑test” (`vitest run`) и “dev watch” (`vitest`) как разные режимы.
- Подчёркивает: UI — точка отказа для всех apps, поэтому тесты лучше держать “рядом с исходниками” в пакете.

**Отражено ли это уже в `web-core`**
- Да: Vitest + RTL + jsdom настроены в `packages/ui` (есть `vitest.config.ts`, `src/test/setup.ts`, `scripts.test`).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Ввести тестовый контур в `packages/ui` первым (как в курсе), затем постепенно расширять на другие пакеты (utils/plugins) при необходимости.
- Зафиксировать для всех “тестируемых” packages минимум: `scripts.test` (CI) и (опционально) `scripts.dev:test` (watch), чтобы разработка UI была быстрой.

---

### 5.2 `5-testing/2-write-component-tests.md`

**Что говорит курс**
- Писать тесты на UI компоненты, чтобы изменения shared UI не ломали все apps.
- Практика: тестировать поведение/контракт компонентов (variants, default props, обработчики, рендер children), а не “внутренности реализации”.
- (Опционально) coverage как артефакт: можно включить v8 provider + html/text отчёты, и это потом можно кешировать turbo‑outputs.

**Отражено ли это уже в `web-core`**
- Да: добавлены базовые UI‑тесты (как минимум для `Button`) и включены в `pnpm test` через Turborepo.

**Есть рекомендации по правкам структуры репозитория?**
- Нет по структуре, но да по обязательным скриптам `test` в ключевых packages.

**Рекомендации**
- Для пакетов, которые являются “точкой отказа” (UI), сделать `test` обязательным (и запускать его в turbo pipeline).
- Если мы включаем coverage в CI: настроить `turbo.json` outputs для `test` так, чтобы coverage реально кешировался и не раздувал cache без пользы.

---

### 5.3 `5-testing/3-configure-turborepo-tests.md`

**Что говорит курс**
- Добавить `test` task в `turbo.json` и кешировать результаты (coverage outputs).
- Важный тезис курса: `test` обычно **без `dependsOn`**, т.к. тесты пакетов не обязаны ждать тестов зависимостей (можно параллелить).
- Диагностика: `turbo test --dry` показывает, какие пакеты реально будут тестироваться.
- Показано: `--force` полезен для отладки кеша.

**Отражено ли это уже в `web-core`**
- Частично: `turbo.json` содержит `test` task (с `outputs: []`), и `packages/ui` имеет `scripts.test`. Coverage‑артефакты пока не генерируются.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Привести `turbo test` к “рабочему состоянию”: добавить `test` хотя бы в `@synestra/ui`, и только потом расширять дальше.
- Определить “стандарт тестирования” по типу пакета:
  - UI: jsdom + RTL + jest-dom.
  - Utils: node env (без jsdom).
  - Config packages: обычно без тестов.

---

### 5.4 `5-testing/4-test-caching.md`

**Что говорит курс**
- Понимать инвалидацию кеша (source/tests/config/скрипты).
- Remote caching усиливает эффект в CI/команде.
- Конкретизирует: в хэш входят исходники, тесты, package config (`package.json`, `tsconfig`, `vitest.config`), глобальные конфиги (`turbo.json`, root `package.json`), а также workspace‑deps (например, shared typescript-config).
- Показывает практику диагностики: `--dry=json` + просмотр task hash.
- Даёт стратегии повышения cache-hit rate: минимизировать churn глобальных конфигов, корректно очертить зависимости, держать стабильные test scripts.

**Отражено ли это уже в `web-core`**
- На уровне понимания — да (в docs уже есть упоминания remote caching), но практическая настройка не сделана.

**Есть рекомендации по правкам структуры репозитория?**
- Да (план/документация).

**Рекомендации**
- Свести правила “что инвалидирует кеш” в один документ (как минимум: `.env.*local`, `turbo.json`, root `package.json`) и учитывать это при планировании изменений.
- Для `web-core`: добавить в этот документ отдельный блок про “workspace‑deps в хэше” (например, изменения в `packages/typescript-config` могут инвалидировать `packages/ui:test`), чтобы это не выглядело как “магия”.

---

## Примечание: отсутствующий раздел про env vars

В конце `5-testing/4-test-caching.md` курс анонсирует следующий раздел “Environment Variables”, но в сохранённом наборе материалов `docs/course/production-monorepostwith-turborepo/**` **нет** отдельной секции/уроков про env vars.

Для `web-core` это критично (Payload/Next + dev/stage/prod + GitOps), поэтому стратегию env‑переменных и их валидации нужно сформировать отдельно, опираясь на:

- исследование Payload templates: `docs/research/templates-research.md` и `docs/research/templates/*`;
- наши ограничения “никаких секретов в репо” и split ответственности с `synestra-platform`.

---

## 6) Section 6 — Pipeline Optimization

### 6.1 `6-pipeline-optimization/1-github-actions.md`

**Что говорит курс**
- CI должен запускать `turbo build lint test` одной командой, чтобы turbo распараллеливал.
- Настройка pnpm + node caching.
- Практика: “одна команда в CI лучше, чем 3 шага” (иначе теряем преимущества оркестрации/кеша).

**Отражено ли это уже в `web-core`**
- Да: добавлен референсный workflow CI в `.github/workflows/ci.yml` (при этом основной CI по‑прежнему может жить в `synestra-platform`).

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Добавить “референсный” CI workflow (OSS) внутри `web-core` как документацию/страховку (даже если основной CI в GitLab).
- Зафиксировать “каноничный набор задач CI” (`build+lint+test`) и ожидания по кешу; реализацию runners/секретов держать в `synestra-platform`.

---

### 6.2 `6-pipeline-optimization/2-filtering-git-based.md`

**Что говорит курс**
- Использовать `--filter=[origin/main]` в CI для инкрементальных билдов.
- Требование `fetch-depth: 0` для git‑сравнения.
- Урок даёт “язык фильтров”: точный пакет, зависимости/зависимые (`...`), сравнение с веткой (`[origin/main]`).

**Отражено ли это уже в `web-core`**
- Частично: `pnpm --filter` используется в docs/runbook; CI‑фильтрации нет.

**Есть рекомендации по правкам структуры репозитория?**
- Да (как часть CI‑контракта).

**Рекомендации**
- Зафиксировать в документации “селективный билд” как стандарт для CI: на PR — фильтр, на main — полный прогон (или наоборот, по политике).
- Для self-host CI: описать минимальные требования для git‑фильтра (доступ к истории/refs), но без привязки к конкретному CI (это в platform repo).

---

### 6.3 `6-pipeline-optimization/3-remote-caching.md`

**Что говорит курс**
- Remote cache делит артефакты между dev и CI; токены/права нужно ограничивать.
- `.turbo/config.json` не коммитить.
- Практика: разделять токены (read-only для CI, write для dev) и явно прокидывать `TURBO_*` в CI окружение (в курсе — Vercel).
- Тезис: кешируются только outputs задач, но важно контролировать, что именно входит в `outputs`.

**Отражено ли это уже в `web-core`**
- Частично: `.turbo/` уже игнорируется; но выбранный remote cache (Vercel или self-host) не закреплён.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Для `web-core` (self-host) выбрать эквивалент “Vercel remote cache” (например, self-host turbo remote cache) и описать только интерфейс/переменные; секреты и развёртывание — в `synestra-platform`.
- В `web-core` держать правило “outputs не должны содержать секретов/персональных данных” и список допустимых outputs (включая coverage, если включим).

---

## 7) Section 7 — Scaling to Multiple Apps

### 7.1 `7-add-third-app/1-add-docs-app.md`

**Что говорит курс**
- Добавление третьего app должно быть “дешёвым”: reuse shared packages/configs.
- В примере используется `NEXT_PUBLIC_*` env и (в курсе) “env validation” как отдельный слой.
- В уроке третий app выступает как “витрина” shared UI и как проверка, что CI/filtering/remote cache масштабируются без изменения подхода.
- Акцент на стандартизацию портов (3002 для третьего app) и на multi-app dev (`pnpm dev`).

**Отражено ли это уже в `web-core`**
- Да частично: уже есть несколько apps и shared packages.
- Env validation у нас точечная (проверки в payload.config.ts), но нет общей стратегии.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Ввести стандарт для env‑контракта на уровне каждого app: `.env.example` + проверка “required in production” (для Payload и Next runtime), не смешивая секреты/несекреты.
- Для `web-core`: если появится “docs app” (или любой не-Payload app), заранее определить:
  - где он живёт (`apps/docs`),
  - какие shared packages ему разрешены (`@synestra/ui`, `@synestra/utils`, configs),
  - и как его деплоим/изолируем от production (например, отдельный домен/namespace).

---

### 7.2 `7-add-third-app/2-deploy-all-apps.md`

**Что говорит курс**
- Независимые деплои для 3 apps; изменение shared package вызывает ребилд всех зависимых apps.
- Подчёркивается раздельный env per app (на Vercel это per-project env vars).
- Верификация “independent deploy” через два сценария:
  - change only app → redeploy только этого app,
  - change shared package → redeploy всех dependents.

**Отражено ли это уже в `web-core`**
- Да по архитектуре GitOps (один Application на deployment), но “реальные URL/домены” и CI‑связка пока placeholders.

**Есть рекомендации по правкам структуры репозитория?**
- Да.

**Рекомендации**
- Для каждого app держать отдельные values (как сейчас) и явно документировать “что считается изменением, требующим деплоя зависимых apps” (shared packages).
- Для self-host/GitOps: явно зафиксировать “политику триггеров” в platform CI:
  - изменение в `packages/ui` ⇒ rebuild+deploy всех apps, которые реально от него зависят,
  - изменение в `apps/<one>` ⇒ rebuild+deploy только одного app,
  - изменение в docs/README ⇒ деплой не требуется (если политика такова).

---

### 7.3 `7-add-third-app/3-multi-app-development.md`

**Что говорит курс**
- Практики multi-app dev: `pnpm dev`, `pnpm --filter`, порты, VSCode workspace.
- Даёт конкретные паттерны запуска:
  - всё сразу (`pnpm dev`),
  - один app (`pnpm --filter @.../<app> dev`),
  - несколько apps (несколько `--filter`),
  - запуск по glob (`--filter "./apps/*"`).
- Практики DX: кросс-ссылки между локальными apps, управление портами, отдельные browser profiles, tmux.

**Отражено ли это уже в `web-core`**
- Да: порты и команды описаны в `docs/runbooks/runbook-dev.md`, VSCode workspace уже есть (`.vscode/web-core.code-workspace`).

**Есть рекомендации по правкам структуры репозитория?**
- Нет (в целом уже выполнено), кроме возможной детализации.

**Рекомендации**
- Держать “таблицу портов” и стандарт `pnpm --filter` команд в одном месте (уже есть) и обновлять при добавлении app.
- Для `web-core`: добавить краткий “канон multi-app dev” в `docs/runbooks/runbook-dev.md` (или ссылкой на него из курса), включая примеры `--filter "./apps/*"` и “когда запускать всё vs один app”.

---

## 8) Section 8 — Enterprise Patterns

### 8.1 `8-enterprise-patterns/1-turborepo-generators.md`

**Что говорит курс**
- Автоматизировать шаблоны компонент/пакетов через `@turbo/gen` (plop‑подобные генераторы).
- Пример генератора `component`: создаёт `packages/ui/src/<kebab>.tsx`, тест `*.test.tsx`, и добавляет экспорт в `packages/ui/src/index.ts`.
- Пример генератора `package` (опционально): `addMany` по шаблону, чтобы создавать новый `packages/<name>` со стандартным набором файлов.
- Ценность: уменьшение ошибок (забыли export / забыли test / несовместимый нейминг) и единый “канон” для команды.

**Отражено ли это уже в `web-core`**
- Частично: есть директория `turbo/` и заготовка под generators, но генераторы не внедрены как стандарт.

**Есть рекомендации по правкам структуры репозитория?**
- Да (опционально, позже).

**Рекомендации**
- Ввести генераторы после стабилизации структуры `packages/ui` и появления тестового контура (иначе генератор будет плодить неустойчивый шаблон).
- Если внедряем: зафиксировать scope генераторов (минимум `component` для `@synestra/ui`), и DoD шаблона:
  - создаёт компонент + тест,
  - обновляет public API (export),
  - не вносит app‑специфику,
  - соответствует нашему стилю (TS/ESLint/Prettier) и naming (`@synestra/*`).

---

### 8.2 `8-enterprise-patterns/2-changesets-versioning.md`

**Что говорит курс**
- Использовать Changesets для версионирования shared packages и генерации changelog.

**Отражено ли это уже в `web-core`**
- Нет (и есть вопрос применимости, т.к. пакеты не публикуются в npm).

**Есть рекомендации по правкам структуры репозитория?**
- Да (как опциональный инструмент governance).

**Рекомендации**
- Рассмотреть Changesets как внутренний механизм “release notes” для shared packages даже без npm‑публикации; решение отложить до момента, когда появится реальная потребность в отслеживании изменений `packages/*`.

---

### 8.3 `8-enterprise-patterns/3-code-governance.md`

**Что говорит курс**
- CODEOWNERS + branch protection как базовая governance практика.

**Отражено ли это уже в `web-core`**
- Да: `.github/CODEOWNERS` присутствует и отражает владение областями.

**Есть рекомендации по правкам структуры репозитория?**
- Нет (минимум уже есть).

**Рекомендации**
- По мере роста: уточнить ownership по “критичным” областям (deploy/tooling/shared packages) и поддерживать актуальность.

---

### 8.4 `8-enterprise-patterns/4-next-forge-patterns.md`

**Что говорит курс**
- next-forge как “витрина” production‑паттернов: более тонкие package boundaries, Biome, security headers, rate limiting, аналитика/наблюдаемость, более сложный turbo pipeline.

**Отражено ли это уже в `web-core`**
- Частично: структура apps/packages уже есть, но прод‑паттерны безопасности/observability не внедрены.

**Есть рекомендации по правкам структуры репозитория?**
- Да (как источник идей, не как обязательный blueprint).

**Рекомендации**
- Использовать next-forge как “каталог идей”, но переносить только то, что не конфликтует с self-host/k3s и Payload:
  - security headers/CSP как стандарт для Next apps,
  - более строгие границы пакетов (по доменам) — по мере роста,
  - оценить Biome как альтернативу ESLint+Prettier (но не вводить до стабилизации текущего tooling).
