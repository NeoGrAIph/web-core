# Критерии выбора GoF‑паттерна (и предварительный отсев неподходящих)

Контекст: этот курс про **production monorepo + Turborepo**, а наш репозиторий — **Payload CMS 3.x + Next.js 15.x + Kubernetes**. Мы хотим уметь *по критериям* определить, какой из GoF (Gang of Four) паттернов уместен для:

- анализа глав курса (что автор фактически применяет/рекомендует);
- анализа и рефакторинга `web-core` (что нам стоит внедрять, а что будет “овер‑инжинирингом”).

Источник каталога: *Design Patterns: Elements of Reusable Object‑Oriented Software* (Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, 1994) — 23 паттерна.

---

## 0) Предупреждение про “переносимость” GoF в TypeScript/Next.js

GoF формулировались для классического OOP. В современном TypeScript/React многие паттерны реализуются:

- **функциями/модулями/композицией**, а не наследованием;
- **конфигурацией** (например, `turbo.json`, `next.config.*`, `eslint.config.*`);
- **инверсией зависимостей через границы пакетов** (workspace packages), а не через “глобальные синглтоны”.

Поэтому “выбор паттерна” здесь означает: *выбор структурного решения и стабильной точки расширения*, а не обязательно буквально “класс + интерфейс”.

---

## 1) Как выбирать паттерн: 7 вопросов‑фильтров

Перед тем как назвать паттерн — ответь “да/нет” на вопросы. Это снижает риск натянуть паттерн на задачу.

1) **Какая ось изменения?** Что будет меняться чаще всего:
   - алгоритм/правила (варианты поведения);
   - интеграция/адаптеры (внешние API/библиотеки);
   - состав частей (композиция UI/блоков/пайплайна);
   - построение сложного объекта/конфига (шаги/варианты);
   - жизненный цикл (состояния/переходы).

2) **Сколько вариантов уже есть и сколько реально будет?**
   - 1 вариант и не ожидается рост → паттерн обычно не нужен.
   - 2+ вариантов или ожидаемый рост → паттерн может окупиться.

3) **Где должна быть точка расширения?**
   - внутри пакета (`packages/*`);
   - на уровне приложения (`apps/*`, “overrides”);
   - на уровне инфраструктуры/CI (`deploy/*`, GitOps, CI).

4) **Нужно ли менять поведение без правок вызывающего кода?**
   - да → часто подходят Strategy/Factory/Adapter/Decorator/Facade/Proxy.

5) **Нужно ли гарантировать совместимость и стабильный контракт?**
   - да → сильный сигнал в пользу Facade/Adapter/Abstract Factory (как контракт сборки объектов), а также чётких интерфейсов/типов.

6) **Нужны ли ограничения среды выполнения?**
   - server/client, SSR, edge/runtime, tree‑shaking, lazy imports, “no side effects”.
   - если да → избегаем решений, которые тянут тяжёлые зависимости/глобальные эффекты ради “красоты паттерна”.

7) **Есть ли более простой эквивалент?**
   - простая функция/модуль, таблица конфигурации, композиция компонентов, типизированный registry.
   - если да и это читаемо → предпочтительнее, чем усложнение “ради паттерна”.

---

## 2) Критерии “паттерн нужен” vs “паттерн не нужен”

### Паттерн оправдан, если:
- есть **повторяемая боль** (дубли, хрупкие зависимости, “если‑лес”);
- есть **независимые причины изменения** (SRP нарушен и это мешает);
- нужен **стабильный контракт** между слоями (app ↔ package, UI ↔ домен, CI ↔ build);
- ожидается **рост вариантов** (новые сайты/темы/адаптеры/блоки/пайплайны);
- появляется **тестируемость** (можно подменять реализации/стратегии).

### Паттерн НЕ оправдан, если:
- вариантов фактически 1 и это надолго;
- паттерн добавляет уровни абстракции без измеримого эффекта (DX/риск/скорость);
- решение зависит от “магии” резолвинга/рантайма, которая плохо отлаживается (особенно в Next.js);
- проще и яснее решить “плоско” (модуль + функции + типы).

---

## 3) Предварительный отсев: какие GoF‑паттерны обычно *малосигнальны* для нашего контекста

Это **не запрет**, а “по умолчанию не рассматриваем”, пока не увидим явные признаки.

### Обычно не приоритет (нужны сильные доказательства):
- **Interpreter** — нужен, если мы реально строим DSL/язык (например, собственный язык правил/шаблонов).
- **Memento** — нужен для undo/redo (редактор, история состояния на клиенте).
- **Prototype** — нужен для клонирования сложных объектов с вариативной конфигурацией (в JS чаще решается иначе).
- **Flyweight** — нужен при экстремальной экономии памяти на огромном числе однотипных объектов (редко узкое место в наших задачах).
- **Visitor** — нужен для “обхода структур” с множеством операций (AST/деревья), чаще актуален для кодемодов/линтеров, а не для app‑кода.
- **Mediator** — нужен при сложной “сетке” взаимодействий между множеством объектов; в React/Next чаще лучше решать явными данными + композиция.

Если в главе курса/в коде нет:
- DSL/парсинга,
- undo/redo,
- AST‑преобразований,
- проблем памяти,
- сложной сетки взаимодействий,
то эти паттерны, как правило, можно не тянуть в анализ.

---

## 4) “Кандидаты по умолчанию”: что чаще всего встречается в monorepo/Next.js/Payload

Ниже — “карта соответствий”: **какой симптом → какой паттерн проверять первым**.

### 4.1 Пакеты и границы: shared ↔ app‑override
- **Facade**: “единая точка импорта/контракта” (`@/ui/*`, `@synestra/*`), чтобы скрыть внутренности и дать override‑слой.
- **Adapter**: когда внешний пакет/SDK “не такой”, и нужен совместимый интерфейс.
- **Abstract Factory / Factory Method**: когда нужно собирать семейства зависимостей (например, storage adapter + media URL builder + client config) под разные среды.

### 4.2 UI/композиция/страницы
- **Composite**: дерево UI/блоков (page builder блоки, layout‑секции, вложенные компоненты).
- **Decorator**: обёртки вокруг компонентов (варианты, “enhancers”, instrumentation), но аккуратно с побочными эффектами.
- **Strategy**: “вариант поведения” (рендереры, форматтеры, валидаторы, правила).

### 4.3 Инфраструктура/пайплайны/запуски задач
- **Command**: “действия” как сущности (CLI задачи, jobs: refresh db/media, миграции).
- **Template Method**: общий скелет процесса (build/test/deploy) + переопределяемые шаги.
- **Chain of Responsibility**: цепочки обработчиков (валидация, pre/post hooks), когда нужен порядок и возможность “останавливать” цепь.

### 4.4 Состояния, жизненный цикл, режимы
- **State**: если есть явные режимы (draft/preview/live, seed/not seeded, ready/migrating).
- **Observer**: события/подписки (в UI или бекэнде), но в современном стеке часто выражается через event emitter / hooks.

### 4.5 Оптимизация/кэш/ленивые зависимости
- **Proxy**: обёртка для lazy‑init, кеширования, ограничения доступа (например, к внешнему API).
- **Singleton**: только если нужен “один инстанс на процесс” (но в serverless/Next это tricky; чаще лучше фабрика + кэш в модуле).

---

## 5) Мини‑чеклист: как доказать, что паттерн “встречается” в главе курса

Чтобы не заниматься “натягиванием”, фиксируем:

1) **Текстовое свидетельство**: в главе явно есть рекомендация (“вынеси общее”, “сделай абстракцию”, “единая точка импорта”, “registry”).
2) **Артефакт**: файл/конфиг/структура, которая выражает паттерн (например, `packages/*`, `turbo.json`, “UI package”, генераторы).
3) **Причина**: какую проблему решает (скорость, независимые деплои, переиспользование, тестирование).
4) **Компромисс**: чем платим (сложность, обучение, дополнительные слои).
5) **Альтернатива**: что было бы проще/хуже без паттерна.

Эти 5 пунктов используем как формат записи выводов в `recommendations.md`.

---

## 6) Список 23 GoF‑паттернов (для индексации)

**Порождающие (Creational)**: Abstract Factory, Builder, Factory Method, Prototype, Singleton.  
**Структурные (Structural)**: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.  
**Поведенческие (Behavioral)**: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor.

---

## 7) Как мы применим это к курсу дальше

Дальнейший шаг (в рамках исследования курса):

- Для каждой главы курса: выписать **1–3 наиболее вероятных паттерна** (из раздела 4), подтвердить по чеклисту (раздел 5), и только потом делать рекомендации для `web-core`.

---

## 8) Оценка применимости GoF‑паттернов по материалам курса (Section 0–8)

Правило:
- Оценка **0–10** — насколько в конкретном уроке читается “паттерн‑подобная” идея/конструкция и насколько она переносима в `web-core`.
- `—` — по тексту урока **нет достаточных сигналов**, чтобы уверенно привязать паттерн (не “0”, а именно “не выводится из источника”).

Уроки:
- `0` = `introduction.md`
- `1.1` = `1-understanding-monorepos.md`
- `1.2` = `2-monorepos-vs-polyrepos.md`
- `1.3` = `3-turborepo-basics.md`
- `2.1` = `2-first-shared-package/1-add-features-page.md`
- `2.2` = `2-first-shared-package/2-create-ui-package.md`
- `2.3` = `2-first-shared-package/3-extract-card.md`
- `2.4` = `2-first-shared-package/4-extract-button-component.md`
- `2.5` = `2-first-shared-package/5-deploy-web-app.md`
- `3.1` = `3-second-app/1-create-snippet-app.md`
- `3.2` = `3-second-app/2-build-snippet-list-page.md`
- `3.3` = `3-second-app/3-add-codeblock-snippetcard.md`
- `3.4` = `3-second-app/4-snippet-creation-modal.md`
- `3.5` = `3-second-app/5-deploy-both-apps.md`
- `4.1` = `4-shared-configs-and-utils/1-extract-shared-configs.md`
- `4.2` = `4-shared-configs-and-utils/2-add-shared-utils.md`
- `4.3` = `4-shared-configs-and-utils/3-update-turborepo-pipeline.md`
- `5.1` = `5-testing/1-set-up-vitest.md`
- `5.2` = `5-testing/2-write-component-tests.md`
- `5.3` = `5-testing/3-configure-turborepo-tests.md`
- `5.4` = `5-testing/4-test-caching.md`
- `6.1` = `6-pipeline-optimization/1-github-actions.md`
- `6.2` = `6-pipeline-optimization/2-filtering-git-based.md`
- `6.3` = `6-pipeline-optimization/3-remote-caching.md`
- `7.1` = `7-add-third-app/1-add-docs-app.md`
- `7.2` = `7-add-third-app/2-deploy-all-apps.md`
- `7.3` = `7-add-third-app/3-multi-app-development.md`
- `8.1` = `8-enterprise-patterns/1-turborepo-generators.md`

### 8.1 Матрица (23 GoF)

| GoF паттерн | 0 | 1.1 | 1.2 | 1.3 | 2.1 | 2.2 | 2.3 | 2.4 | 2.5 | 3.1 | 3.2 | 3.3 | 3.4 | 3.5 | 4.1 | 4.2 | 4.3 | 5.1 | 5.2 | 5.3 | 5.4 | 6.1 | 6.2 | 6.3 | 7.1 | 7.2 | 7.3 | 8.1 |
|---|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
| Abstract Factory | — | — | — | — | — | — | — | — | — |
| Builder | — | — | — | — | — | 4 | 5 | 5 | — | 6 | — | 4 | — | — | 6 | 6 | 4 | 4 | 4 | 3 | — | 4 | 4 | — | 5 | — | — | 9 |
| Factory Method | — | — | — | — | — | — | — | — | — |
| Prototype | — | — | — | — | — | — | — | — | — |
| Singleton | — | — | — | — | — | — | — | — | — |
| Adapter | — | — | — | — | — | — | — | — | — |
| Bridge | — | — | — | — | — | — | — | — | — |
| Composite | — | 6 | — | 6 | 4 | 5 | 6 | 6 | 5 | 5 | 6 | 9 | 4 | 5 | 5 | 4 | 7 | 4 | 5 | 6 | 6 | 5 | 6 | 6 | 6 | 6 | 5 |
| Decorator | — | — | — | — | — | — | — | — | — |
| Facade | 4 | 8 | 6 | 5 | — | 9 | 8 | 7 | 4 | 6 | 7 | 8 | 4 | 6 | 8 | 6 | 5 | 4 | 4 | 5 | 4 | 5 | 7 | 6 | 5 | 6 | 5 | 6 |
| Flyweight | — | — | — | — | — | — | — | — | — |
| Proxy | — | — | — | — | — | — | — | — | — |
| Chain of Responsibility | — | — | — | 4 | — | — | — | — | 3 | — | — | — | — | 4 | — | — | 5 | — | — | 4 | 4 | 4 | 6 | 5 | 4 | 5 | 6 |
| Command | 5 | 4 | — | 9 | 3 | 5 | 4 | 3 | 8 | 6 | 4 | 4 | 6 | 9 | 5 | 4 | 6 | 5 | 4 | 7 | 5 | 8 | 8 | 8 | 6 | 7 | 9 | 7 |
| Interpreter | — | — | — | — | — | — | — | — | — |
| Iterator | — | — | — | — | — | — | — | — | — |
| Mediator | — | — | — | — | — | — | — | — | — |
| Memento | — | — | — | — | — | — | — | — | — |
| Observer | — | — | — | — | — | — | — | — | — |
| State | — | — | — | — | — | — | — | — | — | — | — | — | 7 | — | — | — | — | — | — | — | — |
| Strategy | — | — | — | 6 | — | — | — | 8 | 6 | — | — | — | — | 6 | 4 | 5 | 7 | 4 | 6 | 7 | 9 | 6 | 9 | 8 | 6 | 7 | 6 | 5 |
| Template Method | 6 | — | — | 7 | 6 | 6 | 7 | 6 | 7 | 6 | 6 | 7 | 6 | 7 | 7 | 6 | 8 | 6 | 7 | 7 | 8 | 7 | 8 | 7 | 7 | 7 | 7 | 8 |
| Visitor | — | — | — | — | — | — | — | — | — |

### 8.2 Обоснования по урокам (только там, где стоят баллы)

#### `0) introduction.md`
- **Template Method (6/10)**: курс задаёт “скелет” процесса (постоянный deploy, метрики, прогрессивная сложность) — это похоже на канонизацию общего алгоритма, где детали в следующих разделах.
- **Command (5/10)**: тезисы “deploy constantly / measure” подразумевают повторяемые действия (build/deploy/verify) как дискретные операции.
- **Facade (4/10)**: на уровне идеи — “монорепо как единый вход” для множества apps/packages, но в уроке мало конкретных артефактов.

#### `1.1) 1-understanding-monorepos.md`
- **Facade (8/10)**: “root coordinates, apps implement” — единая точка запуска/координации (root scripts + `turbo.json`) скрывает детали app‑скриптов.
- **Composite (6/10)**: монорепо описывается как иерархия/граф `apps/*` + (позже) `packages/*` с зависимостями; это ментальная модель “дерево/граф компонентов”.
- **Command (4/10)**: root‑скрипты (`turbo run <task>`) формализуют действия как команды, но урок больше про структуру, чем про “команды как объекты”.

#### `1.2) 2-monorepos-vs-polyrepos.md`
- **Facade (6/10)**: ключевая боль polyrepo — отсутствие единого “контракта/входа” и атомарности. Монорепо предлагает единый слой для shared‑кода и потребителей (по сути, фасад для координации изменений).

#### `1.3) 3-turborepo-basics.md`
- **Command (9/10)**: “tasks” (`build/lint/dev`) — явно оформленные команды, которые можно запускать, кешировать, планировать и воспроизводить.
- **Template Method (7/10)**: общий скелет пайплайна (“выполни build с `dependsOn` и `outputs`”), при этом конкретные шаги реализуют сами пакеты (Next build, tsc, etc.).
- **Strategy (6/10)**: настройки кеширования (`outputs`, инвалидация по inputs/env) — выбор стратегии выполнения задачи (cache hit vs cache miss) и критериев её переключения.
- **Composite (6/10)**: `dependsOn: ["^build"]` опирается на граф зависимостей пакетов; Turborepo оркестрирует обход этого графа.
- **Chain of Responsibility (4/10)**: `dependsOn` задаёт последовательность “сначала зависимости, потом пакет”; это похоже на цепочку, но без явных “handlers” в коде — поэтому оценка умеренная.

#### `2.1) 1-add-features-page.md`
- **Composite (4/10)**: страница строится как повторяющаяся композиция одинаковых “карточек” (элементы UI как дерево/композиция), хотя это ещё без явного компонента.
- **Command (3/10)**: шаги урока формализованы как “выполни команду/проверь результат” (`pnpm dev`), но это вторично.
- **Template Method (6/10)**: урок задаёт шаблонный подход “сначала сделать намеренное дублирование, затем вынести в shared” (скелет учебного процесса).

#### `2.2) 2-create-ui-package.md`
- **Facade (9/10)**: `packages/ui` задаёт публичный контракт импорта; особенно через `exports`/subpath импорты — это явный фасад над внутренней структурой пакета.
- **Command (5/10)**: “создай структуру → `pnpm install` → проверь, что workspace увидел пакет” — дискретные команды как шаги.
- **Builder (4/10)**: “сборка” структуры пакета (директории + `package.json` + `tsconfig`) похожа на пошаговое построение артефакта, но это скорее scaffolding, чем полноценный Builder.
- **Composite (5/10)**: добавляется новый узел в граф монорепо (package), который станет зависимостью apps.
- **Template Method (6/10)**: повторяемый скелет создания нового пакета (структура/конфиг/линковка).

#### `2.3) 3-extract-card.md`
- **Facade (8/10)**: компонент становится доступен через стабильный путь импорта `@.../ui/card` — публичный фасад пакета.
- **Composite (6/10)**: UI‑дерево (страница) начинает состоять из узлов `<Card>`; также сохраняется граф “app зависит от package”.
- **Template Method (7/10)**: алгоритм вынесения компонента (создать файл → добавить export → подключить зависимость → заменить usage) — повторяемая “процедура”.
- **Command (4/10)**: шаги “запусти dev, измени Card, проверь мгновенные обновления” — поведенчески похоже на набор команд.
- **Builder (5/10)**: “собираем” компонент как продукт из шагов (создание + экспорт + использование), но это мягкое соответствие.

#### `2.4) 4-extract-button-component.md`
- **Strategy (8/10)**: `variant` выбирает стратегию оформления/поведения (primary/secondary) без копирования кода на местах.
- **Facade (7/10)**: импорт через `@.../ui/button` как публичный контракт.
- **Template Method (6/10)**: повторяет скелет extraction‑процесса из 2.3.
- **Composite (6/10)**: использование `<Button>` как часть UI‑дерева, плюс зависимость app→package.
- **Builder (5/10)**: постепенное наращивание “UI библиотеки” через шаги.
- **Command (3/10)**: шаги проверки через `pnpm dev` и ручные изменения.

#### `2.5) 5-deploy-web-app.md`
- **Command (8/10)**: явно оформленные действия (`turbo build --filter=...`, `--force`, commit/push, деплой) — “операции” с наблюдаемым результатом.
- **Template Method (7/10)**: скелет CI процесса “install → turbo build (filtered) → outputs” с верификацией и повтором.
- **Strategy (6/10)**: выбор “строим только нужное” (`--filter`) и стратегия кеширования (local/remote) как ключевой механизм ускорения.
- **Composite (5/10)**: фильтрация/кеширование опираются на граф пакетов и его изменения.
- **Chain of Responsibility (3/10)**: ordering/зависимости в пайплайне присутствуют концептуально, но в уроке это скорее про фильтрацию и кеш.

#### `3.1) 1-create-snippet-app.md`
- **Builder (6/10)**: scaffold через `create-next-app` + доводка package name/port/deps — по сути “построение” app из шагов; в реальности это ближе к scaffolding, но паттерн повторяемый.
- **Command (6/10)**: шаги “создать app / добавить workspace deps / запустить через `pnpm dev` / собрать `turbo build`” — оформленные операции с проверяемыми результатами.
- **Facade (6/10)**: снова проявляется “root coordinates, apps implement”: единая точка запуска (`pnpm dev`) управляет несколькими apps.
- **Composite (5/10)**: монорепо‑граф расширяется ещё одним app‑узлом, зависящим от `packages/ui`.
- **Template Method (6/10)**: урок задаёт повторяемый скелет “как добавлять новый app в монорепо” (шаги/проверки).

#### `3.2) 2-build-snippet-list-page.md`
- **Facade (7/10)**: импорт UI только через публичные subpath (`@.../ui/button`, `@.../ui/card`) — это прямой контракт/фасад над реализацией пакета.
- **Composite (6/10)**: UI‑дерево строится из `<Button>`/`<Card>` + данных; также сохраняется зависимость app→package в графе.
- **Template Method (6/10)**: повторяемая процедура “подключить shared UI → заменить локальную разметку → проверить hot reload”.
- **Command (4/10)**: команды запуска двух apps и проверка hot‑reload — вторичны, но присутствуют явно.

#### `3.3) 3-add-codeblock-snippetcard.md`
- **Composite (9/10)**: явная композиция компонентов: `SnippetCard` = `Card` + `CodeBlock`, плюс иерархия внутри UI‑пакета.
- **Facade (8/10)**: расширение публичного API UI‑пакета через новые subpath exports.
- **Template Method (7/10)**: типовой процесс добавления нового UI‑компонента (создать файл → экспортировать → заменить usage в app → проверить hot reload/cache).
- **Builder (4/10)**: сборка “сложного” компонента из частей присутствует как идея, но больше как композиция, чем как Builder.
- **Command (4/10)**: шаги теста/сборки (dev/build) и наблюдение кеша.

#### `3.4) 4-snippet-creation-modal.md`
- **State (7/10)**: в уроке явно вводятся состояния интерфейса (список snippets, видимость модалки, состояние формы) и переходы между ними; это наиболее прямое соответствие из GoF в данном разделе.
- **Command (6/10)**: обработчики действий (`handleCreateSnippet`, кнопки Cancel/Create) — “команды” в рамках UI‑событий.
- **Template Method (6/10)**: общий скелет добавления интерактивности (state → UI → handlers → reset).
- **Composite (4/10)**: композиция UI элементов внутри модалки присутствует, но не является центральной идеей урока.
- **Facade (4/10)**: использование shared `Button` остаётся через фасадный import path.

#### `3.5) 5-deploy-both-apps.md`
- **Command (9/10)**: деплой‑процедуры как набор команд (commit/push, `turbo build --filter=...`, настройка второго проекта, верификация).
- **Template Method (7/10)**: общий алгоритм “как деплоить app из монорепо” и повторение его для второго приложения.
- **Strategy (6/10)**: стратегия селективных билдов/деплоев (filter + ignored builds) как оптимизация.
- **Chain of Responsibility (4/10)**: сборка зависимостей (сначала `packages/ui`, потом app) как упорядоченная цепочка шагов.
- **Composite (5/10)**: деплой и кеширование опираются на граф пакетов (app зависит от ui).
- **Facade (6/10)**: публичные границы apps и shared packages в монорепо позволяют независимые деплои “снаружи”.

#### `4.1) 1-extract-shared-configs.md`
- **Facade (8/10)**: `packages/typescript-config` и `packages/eslint-config` формируют публичный контракт конфигурации (apps “видят” только эти точки входа, а не копипастят настройки).
- **Template Method (7/10)**: повторяемая процедура “вынести конфиг в package → заставить apps extend/import → проверить, что ловит ошибки одинаково”.
- **Builder (6/10)**: конфиг‑пакеты “собираются” из набора файлов (base/nextjs + eslint config) как артефакт, который затем потребляют apps.
- **Command (5/10)**: явные команды `pnpm lint`, `pnpm install`, “введи ошибку → проверь правило” как операционализированный процесс.
- **Composite (5/10)**: конфиги участвуют в “структуре” монорепо как отдельные узлы (хотя сами по себе не всегда попадают в build graph).
- **Strategy (4/10)**: упоминание Biome как альтернативной стратегии инструментов (не внедряется, поэтому оценка умеренная).

#### `4.2) 2-add-shared-utils.md`
- **Builder (6/10)**: формирование пакета `packages/utils` и постепенное добавление набора функций — по сути “сборка” общего артефакта из шагов.
- **Facade (6/10)**: единая точка импорта `@.../utils` скрывает реализацию/расположение функций и фиксирует контракт.
- **Template Method (6/10)**: повторяемая процедура “вынести повторяемую логику в shared package → подключить dependency → заменить usage”.
- **Strategy (5/10)**: демонстрируется “стратегия” форматирования даты (через `formatDate`) вместо ad-hoc `toLocaleDateString` в app‑коде.
- **Command (4/10)**: шаги установки/проверки/сборки (`pnpm add`, `turbo build`) вторичны.
- **Composite (4/10)**: `apps/snippet-manager` начинает зависеть от `packages/utils` (усложнение графа).

#### `4.3) 3-update-turborepo-pipeline.md`
- **Template Method (8/10)**: фиксируется общий скелет пайплайна (сначала “пакеты”, затем “apps”), и он повторяем/масштабируем на новые packages/apps.
- **Strategy (7/10)**: выбор стратегии “build для пакетов = typecheck (`tsc --noEmit`)" и стратегия кеширования/инвалидации по графу.
- **Composite (7/10)**: явная визуализация dependency graph и то, как Turborepo обходит его при `^build`.
- **Chain of Responsibility (5/10)**: `dependsOn: ["^build"]` задаёт упорядоченную цепочку “сначала зависимости, потом пакет/app”, уже более явно, чем в ранних уроках.
- **Command (6/10)**: диагностика через `--dry`, последовательные эксперименты “измени util → rebuild зависимого app” как набор команд с наблюдаемым результатом.
- **Facade (5/10)**: `turbo.json` как единая точка декларации правил выполнения задач для всего монорепо.

#### `5.1) 1-set-up-vitest.md`
- **Template Method (6/10)**: повторяемый “рецепт” поднятия тестового контура (deps → config → setup file → scripts → smoke test).
- **Command (5/10)**: тестовые действия оформлены как команды (`pnpm --filter ... test`, `dev:test`) и проверяемые шаги.
- **Composite (4/10)**: тестовая инфраструктура встраивается в структуру пакета рядом с компонентами.
- **Facade (4/10)**: `vitest.config.ts` и `src/test/setup.ts` дают единый интерфейс тестовой среды для всех тестов UI.
- **Builder (4/10)**: “сборка” тестового окружения из нескольких файлов/шагов.
- **Strategy (4/10)**: выбор test environment (jsdom vs node) как стратегия выполнения тестов.

#### `5.2) 2-write-component-tests.md`
- **Template Method (7/10)**: паттерн “для каждого компонента: default props → variants → events/handlers → edge cases” как повторяемый шаблон тестирования.
- **Composite (5/10)**: тестируются компоненты и их композиция (Card/CodeBlock/косвенно SnippetCard), т.е. дерево UI и его свойства.
- **Command (4/10)**: интерактивность (click handler) тестируется как “команда”/действие.
- **Strategy (6/10)**: в явном виде проверяются варианты поведения/рендера (variants, optional props) как “стратегии”.
- **Builder (4/10)**: тесты “собирают” ситуацию из props/DOM, но это слабое соответствие.
- **Facade (4/10)**: тесты закрепляют публичный контракт компонентов (что apps ожидают), выступая как “документация интерфейса”.

#### `5.3) 3-configure-turborepo-tests.md`
- **Command (7/10)**: `turbo test`, `--dry`, `--force` и scripts формализуют тест как задачу/операцию в пайплайне.
- **Template Method (7/10)**: общий алгоритм включения нового task в turbo pipeline (объявить task → outputs → scripts → проверить кеш).
- **Composite (6/10)**: тест‑оркестрация идёт по графу пакетов (что тестировать в workspace).
- **Chain of Responsibility (4/10)**: есть обсуждение `dependsOn` (и его отсутствия) как выбора порядка задач; но здесь акцент на параллельности, поэтому оценка умеренная.
- **Facade (5/10)**: `turbo.json` снова как единая точка управления тестовым пайплайном.
- **Strategy (7/10)**: стратегия кеширования тестов (outputs/coverage, когда инвалидируется, когда форсить).

#### `5.4) 4-test-caching.md`
- **Strategy (9/10)**: вся глава про стратегии максимизации cache-hit, выбор inputs, минимизацию churn, корректное очерчивание зависимостей.
- **Template Method (8/10)**: повторяемый сценарий диагностики кеша (baseline → изменить source/test/config → наблюдать miss/hit → `--dry=json`).
- **Command (5/10)**: набор диагностических команд (`turbo test`, `--dry=json`, `--force`) как инструменты.
- **Composite (6/10)**: инвалидация/селективность описываются через dependency graph (что влияет на что).
- **Chain of Responsibility (4/10)**: глобальные конфиги как “верхняя цепь” влияния (turbo.json → все), но это скорее причинно-следственная цепь, чем кодовый паттерн.

#### `6.1) 1-github-actions.md`
- **Command (8/10)**: CI пайплайн выражен как набор операций (checkout, setup, install, `turbo build lint test`) с наблюдаемым результатом.
- **Template Method (7/10)**: общий “скелет” CI для монорепо (одинаковые шаги для любых проектов, меняются детали env/секретов/платформы).
- **Strategy (6/10)**: стратегия запуска задач одной командой (для максимальной параллельности) и стратегия кеширования зависимостей.
- **Composite (5/10)**: CI прогоняет задачи по набору пакетов (структура монорепо как “составная система”).
- **Builder (4/10)**: сборка workflow из декларативных шагов.
- **Facade (5/10)**: workflow выступает единым интерфейсом “проверить репо” для внешнего мира (PR checks).

#### `6.2) 2-filtering-git-based.md`
- **Strategy (9/10)**: выбор стратегии выполнения задач по affected scope (`--filter`, `[origin/main]`) для ускорения CI.
- **Command (8/10)**: команды `turbo ... --filter=...` превращают “что запускать” в явные операции.
- **Template Method (8/10)**: повторяемая схема “PR = filtered, main = full” и требования (`fetch-depth: 0`) как стандартный шаблон.
- **Composite (6/10)**: affected‑вычисления опираются на граф пакетов/зависимостей.
- **Facade (7/10)**: `--filter=[...]` скрывает детали `git diff + graph` за единым интерфейсом Turbo.
- **Chain of Responsibility (6/10)**: `...` (dependencies/dependents) задаёт “цепочки влияния” по графу, определяя, что должно выполниться вслед за изменением.
- **Builder (4/10)**: “сборка” набора исполняемых задач из фильтров/правил.

#### `6.3) 3-remote-caching.md`
- **Strategy (8/10)**: стратегия кеша “shared across machines” и политика токенов (read-only CI vs write dev), а также контроль `outputs`.
- **Command (8/10)**: шаги включения remote cache (`turbo login/link`, прокидывание `TURBO_*` в CI) как операциональные команды.
- **Template Method (7/10)**: повторяемый процесс включения remote cache для монорепо (login → link → CI env → verify).
- **Composite (6/10)**: remote cache распространяется на множество задач/пакетов и переиспользует общий граф.
- **Chain of Responsibility (5/10)**: изменение глобальных настроек/outputs влияет на все downstream задачи и кеши (цепочка эффекта на весь пайплайн).
- **Facade (6/10)**: remote caching конфигурируется “снаружи” и даёт общий интерфейс ускорения без изменения каждого пакета.

#### `7.1) 1-add-docs-app.md`
- **Composite (6/10)**: добавление третьего app усиливает “составность” системы; shared packages становятся общими узлами для 3 dependents.
- **Template Method (7/10)**: повторяемый процесс добавления app (package.json + port + configs + подключение shared) как стандартная процедура.
- **Facade (5/10)**: reuse `@.../ui`/configs/utils через публичные контракты.
- **Command (6/10)**: операционные шаги `pnpm --filter ... dev`, `pnpm dev`, `turbo build --dry`.
- **Builder (5/10)**: сборка нового app из шагов/конфигураций.
- **Strategy (6/10)**: выбор “витрины”/docs app как стратегии валидации масштабируемости и reuse.

#### `7.2) 2-deploy-all-apps.md`
- **Command (7/10)**: процедуры деплоя 3 проектов и проверки (изменил app → деплоится один; изменил shared → деплоятся все).
- **Template Method (7/10)**: повторяемый шаблон деплоя “ещё одного app из того же монорепо”.
- **Composite (6/10)**: зависимость всех apps от shared пакета делает “эффект изменения” графовым.
- **Strategy (7/10)**: стратегия независимых деплоев + стратегия триггеров на изменения (affected deploys).
- **Facade (6/10)**: единый контракт shared packages облегчает независимую сборку/деплой приложений.
- **Chain of Responsibility (5/10)**: shared package change → downstream deploys всех dependents (цепочка эффекта).

#### `7.3) 3-multi-app-development.md`
- **Command (9/10)**: набор практических команд/паттернов запуска (`pnpm dev`, `--filter`, globs, tmux) — по сути “операционный каталог”.
- **Strategy (6/10)**: стратегия “запускай только нужное” vs “запускай всё” для производительности.
- **Template Method (7/10)**: повторяемые workflow‑шаблоны (single-app feature, package dev, cross-app testing).
- **Composite (5/10)**: работа с несколькими apps как с составной системой (порты/кросс-ссылки/единый dev-процесс).

#### `8.1) 1-turborepo-generators.md`
- **Builder (9/10)**: генераторы буквально “строят” артефакты (компонент/пакет) по шагам (файлы, тесты, exports) из шаблонов.
- **Template Method (8/10)**: задаётся общий шаблон процесса создания компонента (вопросы → набор действий), где изменяется только параметр (имя).
- **Command (7/10)**: `turbo gen component/package` — явные команды, которые выполняют repeatable operations.
- **Facade (6/10)**: генератор предоставляет единый интерфейс “создай правильно”, скрывая детали структуры и требований (где лежит файл, как назвать, что экспортировать).
- **Strategy (5/10)**: выбор, какие именно шаблоны/действия включить в генератор (например, с тестом/без теста, с subpath export/без).
