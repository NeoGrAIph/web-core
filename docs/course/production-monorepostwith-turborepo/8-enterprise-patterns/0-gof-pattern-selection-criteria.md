# Критерии выбора GoF‑паттерна (и предварительный отсев неподходящих)

Контекст: этот курс про **production monorepo + Turborepo**, а наш репозиторий — **Payload CMS 3.x + Next.js 15.x + Kubernetes**. Мы хотим уметь *по критериям* определить, какой из GoF (Gang of Four) паттернов уместен для:

- анализа глав курса (что автор фактически применяет/рекомендует);
- анализа и рефакторинга `web-core` (что нам стоит внедрять, а что будет “овер‑инжинирингом”).

Источник каталога: *Design Patterns: Elements of Reusable Object‑Oriented Software* (Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, 1994) — 23 паттерна.

---

## 0) Предупреждение про “переносимость” GoF в TypeScript/Next.js

GoF формулировались для классического OOP. В современном TypeScript/React многие паттерны реализуются:

- **функциями/модулями/композицией**, а не наследованием;
- **конфигурацией** (например, `turbo.json`, `next.config.*`, `eslint.config.*`);
- **инверсией зависимостей через границы пакетов** (workspace packages), а не через “глобальные синглтоны”.

Поэтому “выбор паттерна” здесь означает: *выбор структурного решения и стабильной точки расширения*, а не обязательно буквально “класс + интерфейс”.

---

## 1) Как выбирать паттерн: 7 вопросов‑фильтров

Перед тем как назвать паттерн — ответь “да/нет” на вопросы. Это снижает риск натянуть паттерн на задачу.

1) **Какая ось изменения?** Что будет меняться чаще всего:
   - алгоритм/правила (варианты поведения);
   - интеграция/адаптеры (внешние API/библиотеки);
   - состав частей (композиция UI/блоков/пайплайна);
   - построение сложного объекта/конфига (шаги/варианты);
   - жизненный цикл (состояния/переходы).

2) **Сколько вариантов уже есть и сколько реально будет?**
   - 1 вариант и не ожидается рост → паттерн обычно не нужен.
   - 2+ вариантов или ожидаемый рост → паттерн может окупиться.

3) **Где должна быть точка расширения?**
   - внутри пакета (`packages/*`);
   - на уровне приложения (`apps/*`, “overrides”);
   - на уровне инфраструктуры/CI (`deploy/*`, GitOps, CI).

4) **Нужно ли менять поведение без правок вызывающего кода?**
   - да → часто подходят Strategy/Factory/Adapter/Decorator/Facade/Proxy.

5) **Нужно ли гарантировать совместимость и стабильный контракт?**
   - да → сильный сигнал в пользу Facade/Adapter/Abstract Factory (как контракт сборки объектов), а также чётких интерфейсов/типов.

6) **Нужны ли ограничения среды выполнения?**
   - server/client, SSR, edge/runtime, tree‑shaking, lazy imports, “no side effects”.
   - если да → избегаем решений, которые тянут тяжёлые зависимости/глобальные эффекты ради “красоты паттерна”.

7) **Есть ли более простой эквивалент?**
   - простая функция/модуль, таблица конфигурации, композиция компонентов, типизированный registry.
   - если да и это читаемо → предпочтительнее, чем усложнение “ради паттерна”.

---

## 2) Критерии “паттерн нужен” vs “паттерн не нужен”

### Паттерн оправдан, если:
- есть **повторяемая боль** (дубли, хрупкие зависимости, “если‑лес”);
- есть **независимые причины изменения** (SRP нарушен и это мешает);
- нужен **стабильный контракт** между слоями (app ↔ package, UI ↔ домен, CI ↔ build);
- ожидается **рост вариантов** (новые сайты/темы/адаптеры/блоки/пайплайны);
- появляется **тестируемость** (можно подменять реализации/стратегии).

### Паттерн НЕ оправдан, если:
- вариантов фактически 1 и это надолго;
- паттерн добавляет уровни абстракции без измеримого эффекта (DX/риск/скорость);
- решение зависит от “магии” резолвинга/рантайма, которая плохо отлаживается (особенно в Next.js);
- проще и яснее решить “плоско” (модуль + функции + типы).

---

## 3) Предварительный отсев: какие GoF‑паттерны обычно *малосигнальны* для нашего контекста

Это **не запрет**, а “по умолчанию не рассматриваем”, пока не увидим явные признаки.

### Обычно не приоритет (нужны сильные доказательства):
- **Interpreter** — нужен, если мы реально строим DSL/язык (например, собственный язык правил/шаблонов).
- **Memento** — нужен для undo/redo (редактор, история состояния на клиенте).
- **Prototype** — нужен для клонирования сложных объектов с вариативной конфигурацией (в JS чаще решается иначе).
- **Flyweight** — нужен при экстремальной экономии памяти на огромном числе однотипных объектов (редко узкое место в наших задачах).
- **Visitor** — нужен для “обхода структур” с множеством операций (AST/деревья), чаще актуален для кодемодов/линтеров, а не для app‑кода.
- **Mediator** — нужен при сложной “сетке” взаимодействий между множеством объектов; в React/Next чаще лучше решать явными данными + композиция.

Если в главе курса/в коде нет:
- DSL/парсинга,
- undo/redo,
- AST‑преобразований,
- проблем памяти,
- сложной сетки взаимодействий,
то эти паттерны, как правило, можно не тянуть в анализ.

---

## 4) “Кандидаты по умолчанию”: что чаще всего встречается в monorepo/Next.js/Payload

Ниже — “карта соответствий”: **какой симптом → какой паттерн проверять первым**.

### 4.1 Пакеты и границы: shared ↔ app‑override
- **Facade**: “единая точка импорта/контракта” (`@/ui/*`, `@synestra/*`), чтобы скрыть внутренности и дать override‑слой.
- **Adapter**: когда внешний пакет/SDK “не такой”, и нужен совместимый интерфейс.
- **Abstract Factory / Factory Method**: когда нужно собирать семейства зависимостей (например, storage adapter + media URL builder + client config) под разные среды.

### 4.2 UI/композиция/страницы
- **Composite**: дерево UI/блоков (page builder блоки, layout‑секции, вложенные компоненты).
- **Decorator**: обёртки вокруг компонентов (варианты, “enhancers”, instrumentation), но аккуратно с побочными эффектами.
- **Strategy**: “вариант поведения” (рендереры, форматтеры, валидаторы, правила).

### 4.3 Инфраструктура/пайплайны/запуски задач
- **Command**: “действия” как сущности (CLI задачи, jobs: refresh db/media, миграции).
- **Template Method**: общий скелет процесса (build/test/deploy) + переопределяемые шаги.
- **Chain of Responsibility**: цепочки обработчиков (валидация, pre/post hooks), когда нужен порядок и возможность “останавливать” цепь.

### 4.4 Состояния, жизненный цикл, режимы
- **State**: если есть явные режимы (draft/preview/live, seed/not seeded, ready/migrating).
- **Observer**: события/подписки (в UI или бекэнде), но в современном стеке часто выражается через event emitter / hooks.

### 4.5 Оптимизация/кэш/ленивые зависимости
- **Proxy**: обёртка для lazy‑init, кеширования, ограничения доступа (например, к внешнему API).
- **Singleton**: только если нужен “один инстанс на процесс” (но в serverless/Next это tricky; чаще лучше фабрика + кэш в модуле).

---

## 5) Мини‑чеклист: как доказать, что паттерн “встречается” в главе курса

Чтобы не заниматься “натягиванием”, фиксируем:

1) **Текстовое свидетельство**: в главе явно есть рекомендация (“вынеси общее”, “сделай абстракцию”, “единая точка импорта”, “registry”).
2) **Артефакт**: файл/конфиг/структура, которая выражает паттерн (например, `packages/*`, `turbo.json`, “UI package”, генераторы).
3) **Причина**: какую проблему решает (скорость, независимые деплои, переиспользование, тестирование).
4) **Компромисс**: чем платим (сложность, обучение, дополнительные слои).
5) **Альтернатива**: что было бы проще/хуже без паттерна.

Эти 5 пунктов используем как формат записи выводов в `recommendations.md`.

---

## 6) Список 23 GoF‑паттернов (для индексации)

**Порождающие (Creational)**: Abstract Factory, Builder, Factory Method, Prototype, Singleton.  
**Структурные (Structural)**: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.  
**Поведенческие (Behavioral)**: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor.

---

## 7) Как мы применим это к курсу дальше

Дальнейший шаг (в рамках исследования курса):

- Для каждой главы курса: выписать **1–3 наиболее вероятных паттерна** (из раздела 4), подтвердить по чеклисту (раздел 5), и только потом делать рекомендации для `web-core`.

